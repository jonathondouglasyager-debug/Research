<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Master Research Hub v1.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --matrix-green: #00ff41;
            --matrix-dark-green: #008f11;
            --bg-dark: #0d0d0d;
            --border-color: rgba(0, 255, 65, 0.3);
            --text-primary: #00ff41;
            --text-secondary: #00cc33;
            --panel-bg: rgba(13, 13, 13, 0.85);
        }
        
        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow-x: hidden;
            position: relative;
        }
        
        /* Matrix Canvas Background */
        #matrixCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        /* Main Container */
        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        /* Header */
        header {
            text-align: center;
            margin-bottom: 50px;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 30px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-family: 'Orbitron', monospace;
            font-size: 3em;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px var(--matrix-green);
            animation: glowPulse 2s ease-in-out infinite;
        }
        
        @keyframes glowPulse {
            0%, 100% { text-shadow: 0 0 20px var(--matrix-green); }
            50% { text-shadow: 0 0 30px var(--matrix-green), 0 0 40px var(--matrix-dark-green); }
        }
        
        .subtitle {
            font-size: 0.9em;
            color: var(--text-secondary);
            letter-spacing: 2px;
        }
        
        .header-btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        
        .header-btn:hover {
            background: rgba(0, 255, 65, 0.2);
            border-color: var(--matrix-green);
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
        }
        
        /* Controls Panel */
        .controls-panel {
            position: fixed;
            top: 20px;
            right: -320px;
            width: 300px;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 20px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
            transition: right 0.4s ease;
            z-index: 1000;
        }
        
        .controls-panel::before {
            content: '‚öô';
            position: absolute;
            left: -42px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-right: none;
            border-radius: 4px 0 0 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .controls-panel:hover {
            right: 20px;
        }
        
        .controls-panel:hover::before {
            animation: spin 0.5s ease;
        }
        
        @keyframes spin {
            from { transform: translateY(-50%) rotate(0deg); }
            to { transform: translateY(-50%) rotate(180deg); }
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(0, 255, 65, 0.2);
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--matrix-green);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--matrix-green);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--matrix-green);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--matrix-green);
        }
        
        select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9em;
            border-radius: 3px;
            cursor: pointer;
        }
        
        select option {
            background: #0d0d0d;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch.active {
            background: var(--matrix-dark-green);
        }
        
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: var(--matrix-green);
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 0 10px var(--matrix-green);
        }
        
        .toggle-switch.active .toggle-slider {
            transform: translateX(26px);
        }
        
        /* Drop Zone */
        .drop-zone {
            background: var(--panel-bg);
            border: 3px dashed var(--border-color);
            padding: 60px 40px;
            text-align: center;
            border-radius: 4px;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .drop-zone:hover {
            border-color: var(--matrix-green);
            background: rgba(13, 13, 13, 0.95);
        }
        
        .drop-zone.drag-over {
            border-color: var(--matrix-green);
            background: rgba(0, 255, 65, 0.1);
            transform: scale(1.02);
        }
        
        .drop-zone-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.7;
        }
        
        .drop-zone-text {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }
        
        .drop-zone-subtext {
            font-size: 0.85em;
            color: var(--text-secondary);
        }
        
        /* Analysis Section */
        .analysis-section {
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 30px;
            border-radius: 4px;
            display: none;
            animation: slideIn 0.5s ease;
            backdrop-filter: blur(10px);
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .analysis-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.5em;
            color: var(--text-primary);
        }
        
        .file-info {
            font-size: 0.85em;
            color: var(--text-secondary);
        }
        
        .analysis-content {
            line-height: 1.8;
        }
        
        .section-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.1em;
            color: var(--matrix-green);
            margin-top: 25px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .section-title:first-child {
            margin-top: 0;
        }
        
        .text-content {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 3px;
            border-left: 3px solid var(--matrix-green);
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
            color: #00cc33;
        }
        
        .text-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .text-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .text-content::-webkit-scrollbar-thumb {
            background: var(--matrix-green);
            border-radius: 4px;
        }
        
        .key-points {
            list-style: none;
        }
        
        .key-points li {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 255, 65, 0.05);
            border-left: 3px solid var(--matrix-green);
            border-radius: 3px;
        }
        
        .key-points li::before {
            content: "‚ñ∏ ";
            color: var(--matrix-green);
            font-weight: bold;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        /* Entity Categories */
        .entity-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .entity-category {
            background: rgba(0, 255, 65, 0.05);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 20px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .entity-category:hover {
            background: rgba(0, 255, 65, 0.1);
            border-color: var(--matrix-green);
            transform: translateY(-2px);
        }
        
        .category-header {
            font-family: 'Orbitron', monospace;
            font-size: 1.1em;
            color: var(--matrix-green);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .category-count {
            font-size: 0.8em;
            color: var(--text-secondary);
        }
        
        .entity-list {
            list-style: none;
        }
        
        .entity-item {
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 2px solid var(--matrix-green);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .entity-item:hover {
            background: rgba(0, 255, 65, 0.15);
            border-left-width: 4px;
            transform: translateX(4px);
        }
        
        .entity-name {
            color: var(--text-primary);
            font-size: 0.9em;
        }
        
        .entity-count {
            color: var(--text-secondary);
            font-size: 0.85em;
            font-family: 'Orbitron', monospace;
        }
        
        .entity-expanded {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .entity-category:hover .entity-expanded {
            max-height: 500px;
        }
        
        .show-more {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 0.85em;
            cursor: pointer;
            border-top: 1px solid var(--border-color);
            transition: color 0.2s ease;
        }
        
        .show-more:hover {
            color: var(--matrix-green);
        }
        
        .entity-full-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 2000px;
            }
        }
        
        /* Context Section */
        .context-section {
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--matrix-green);
            border-radius: 4px;
            padding: 25px;
            animation: slideIn 0.5s ease;
        }
        
        .context-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .context-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.3em;
            color: var(--matrix-green);
        }
        
        .context-close {
            cursor: pointer;
            font-size: 1.5em;
            color: var(--text-secondary);
            transition: color 0.2s ease;
        }
        
        .context-close:hover {
            color: var(--matrix-green);
        }
        
        .context-item {
            background: rgba(0, 255, 65, 0.05);
            padding: 15px;
            margin-bottom: 12px;
            border-left: 3px solid var(--matrix-green);
            border-radius: 3px;
            line-height: 1.6;
        }
        
        .context-highlight {
            background: rgba(0, 255, 65, 0.3);
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }
        
        /* PDF Page Modal */
        .pdf-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }
        
        .pdf-modal.active {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .pdf-modal-content {
            background: var(--panel-bg);
            border: 2px solid var(--matrix-green);
            border-radius: 4px;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.3);
        }
        
        .pdf-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pdf-modal-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
            color: var(--matrix-green);
        }
        
        .pdf-modal-close {
            cursor: pointer;
            font-size: 1.5em;
            color: var(--text-secondary);
            transition: color 0.2s ease;
            padding: 5px 10px;
        }
        
        .pdf-modal-close:hover {
            color: var(--matrix-green);
        }
        
        .pdf-modal-body {
            padding: 20px;
            overflow: auto;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .pdf-page-container {
            position: relative;
            background: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .pdf-page-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .pdf-modal-footer {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pdf-nav-buttons {
            display: flex;
            gap: 10px;
        }
        
        .pdf-nav-btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
            transition: all 0.2s ease;
        }
        
        .pdf-nav-btn:hover:not(:disabled) {
            background: rgba(0, 255, 65, 0.2);
            border-color: var(--matrix-green);
            transform: translateY(-1px);
        }
        
        .pdf-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .pdf-open-btn {
            background: var(--matrix-dark-green);
            border: 1px solid var(--matrix-green);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            transition: all 0.2s ease;
        }
        
        .pdf-open-btn:hover {
            background: var(--matrix-green);
            color: var(--bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 0 15px var(--matrix-green);
        }
        
        /* Progress Bar */
        .progress-container {
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 30px;
            border-radius: 4px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
            margin-bottom: 15px;
            color: var(--matrix-green);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border-color);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--matrix-dark-green), var(--matrix-green));
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
            color: var(--bg-dark);
            font-weight: bold;
        }
        
        .progress-status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        /* Dashboard Modal */
        .dashboard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }
        
        .dashboard-modal.active {
            display: flex;
        }
        
        .dashboard-content {
            background: var(--panel-bg);
            border: 2px solid var(--matrix-green);
            border-radius: 4px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.3);
        }
        
        .dashboard-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dashboard-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.5em;
            color: var(--matrix-green);
        }
        
        .dashboard-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        
        .project-list {
            list-style: none;
        }
        
        .project-item {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.2s ease;
        }
        
        .project-item:hover {
            background: rgba(0, 255, 65, 0.1);
            border-color: var(--matrix-green);
            transform: translateX(5px);
        }
        
        .project-name {
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
            color: var(--matrix-green);
            margin-bottom: 10px;
        }
        
        .project-meta {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }
        
        .project-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .project-btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }
        
        .project-btn:hover {
            background: rgba(0, 255, 65, 0.2);
            border-color: var(--matrix-green);
        }
        
        .project-btn.danger:hover {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }
        
        /* Research Assistant Panel */
        .assistant-panel {
            position: fixed;
            right: -600px;
            top: 0;
            width: 600px;
            height: 100vh;
            background: var(--panel-bg);
            border-left: 2px solid var(--matrix-green);
            z-index: 1500;
            display: flex;
            flex-direction: column;
            transition: right 0.4s ease;
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.5);
        }
        
        .assistant-panel.active {
            right: 0;
        }
        
        .assistant-header {
            padding: 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .assistant-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.3em;
            color: var(--matrix-green);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .assistant-status {
            font-size: 0.75em;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .assistant-close {
            cursor: pointer;
            font-size: 1.5em;
            color: var(--text-secondary);
            transition: color 0.2s ease;
            padding: 5px 10px;
        }
        
        .assistant-close:hover {
            color: var(--matrix-green);
        }
        
        .assistant-chat {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .assistant-message {
            display: flex;
            flex-direction: column;
            gap: 10px;
            animation: slideIn 0.3s ease;
        }
        
        .message-user {
            align-self: flex-end;
            max-width: 80%;
        }
        
        .message-assistant {
            align-self: flex-start;
            max-width: 85%;
        }
        
        .message-bubble {
            padding: 15px;
            border-radius: 8px;
            word-wrap: break-word;
        }
        
        .message-user .message-bubble {
            background: rgba(0, 255, 65, 0.15);
            border: 1px solid var(--matrix-green);
            color: var(--text-primary);
        }
        
        .message-assistant .message-bubble {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .message-label {
            font-size: 0.75em;
            color: var(--text-secondary);
            margin-bottom: 5px;
            font-family: 'Orbitron', monospace;
        }
        
        .assistant-input-area {
            padding: 20px;
            border-top: 2px solid var(--border-color);
            background: rgba(0, 0, 0, 0.3);
        }
        
        .assistant-input-container {
            display: flex;
            gap: 10px;
        }
        
        .assistant-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 15px;
            border-radius: 4px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.95em;
            resize: none;
            min-height: 50px;
            max-height: 150px;
        }
        
        .assistant-input:focus {
            outline: none;
            border-color: var(--matrix-green);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        }
        
        .assistant-send-btn {
            background: var(--matrix-dark-green);
            border: 1px solid var(--matrix-green);
            color: var(--text-primary);
            padding: 12px 25px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
            transition: all 0.2s ease;
            align-self: flex-end;
        }
        
        .assistant-send-btn:hover:not(:disabled) {
            background: var(--matrix-green);
            color: var(--bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 0 15px var(--matrix-green);
        }
        
        .assistant-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .query-result {
            margin-top: 10px;
            padding: 15px;
            background: rgba(0, 255, 65, 0.05);
            border-left: 3px solid var(--matrix-green);
            border-radius: 3px;
        }
        
        .result-item {
            padding: 10px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .result-item:hover {
            background: rgba(0, 255, 65, 0.1);
            transform: translateX(5px);
        }
        
        .result-count {
            color: var(--matrix-green);
            font-family: 'Orbitron', monospace;
            margin-bottom: 10px;
        }
        
        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        .thinking-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        .stat-item {
            background: rgba(0, 255, 65, 0.05);
            padding: 15px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }
        
        .stat-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.3em;
            color: var(--matrix-green);
            font-family: 'Orbitron', monospace;
        }
        
        /* Loading Animation */
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: var(--matrix-green);
        }
        
        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        /* Hidden File Input */
        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    
    <div class="container">
        <header>
            <h1>Master Research Hub</h1>
            <p class="subtitle">Truth-Seeking Infrastructure v1.0</p>
            <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button class="header-btn" onclick="showDashboard()">üìä Dashboard</button>
                <button class="header-btn" onclick="newProject()">‚ûï New Project</button>
                <button class="header-btn" onclick="saveProject()">üíæ Save Project</button>
                <button class="header-btn" onclick="loadLastSession()">‚èÆ Resume Last</button>
                <button class="header-btn" id="assistantBtn" onclick="toggleAssistant()" style="background: rgba(0, 255, 65, 0.15); border-color: var(--matrix-green);">ü§ñ Research Assistant</button>
                <button class="header-btn" onclick="toggleGlossary()" style="background: rgba(0, 255, 65, 0.1); border-color: var(--matrix-green);">üìö Glossary</button>
            </div>
            <div id="currentProjectDisplay" style="margin-top: 15px; font-size: 0.9em; color: var(--text-secondary);"></div>
        </header>
        
        <div class="controls-panel">
            <div class="control-group">
                <label>Matrix Intensity: <span id="intensityValue">50</span>%</label>
                <input type="range" id="intensitySlider" min="0" max="100" value="50">
            </div>
            
            <div class="control-group">
                <label>Background Brightness: <span id="brightnessValue">100</span>%</label>
                <input type="range" id="brightnessSlider" min="10" max="100" value="100">
            </div>
            
            <div class="control-group">
                <label>Character Set</label>
                <select id="charsetSelect">
                    <option value="katakana">Katakana (Classic Matrix)</option>
                    <option value="binary">Binary (0/1)</option>
                    <option value="hex">Hexadecimal</option>
                    <option value="symbols">Symbols & Glyphs</option>
                    <option value="greek">Greek Letters</option>
                </select>
            </div>
            
            <div class="control-group">
                <div class="toggle-container">
                    <div class="toggle-switch active" id="matrixToggle">
                        <div class="toggle-slider"></div>
                    </div>
                    <label style="margin: 0;">Matrix Background</label>
                </div>
            </div>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-title">Processing Documents...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%;">0%</div>
            </div>
            <div class="progress-status" id="progressStatus">Initializing...</div>
        </div>
        
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">üìÑ</div>
            <div class="drop-zone-text">Drop Files Here or Click to Upload</div>
            <div class="drop-zone-subtext">Supported: PDF, DOCX, XLSX, TXT, MD, HTML, CSV | Multiple files at once</div>
        </div>
        
        <input type="file" id="fileInput" accept=".pdf,.docx,.xlsx,.xls,.txt,.md,.html,.csv" multiple>
        
        <div class="analysis-section" id="analysisSection">
            <div class="analysis-header">
                <div>
                    <div class="analysis-title">Document Analysis</div>
                    <div class="file-info" id="fileInfo"></div>
                </div>
                <button class="header-btn" id="exportProjectBtn" onclick="exportProjectSummary()" style="background: rgba(0, 255, 65, 0.1); display: none;">üì• Export Summary</button>
            </div>
            
            <div class="analysis-content" id="analysisContent">
                <div class="loading">Processing document</div>
            </div>
        </div>
        
        <!-- PDF Page Viewer Modal -->
        <div class="pdf-modal" id="pdfModal">
            <div class="pdf-modal-content">
                <div class="pdf-modal-header">
                    <div class="pdf-modal-title" id="pdfModalTitle">Page 1</div>
                    <div class="pdf-modal-close" onclick="closePdfModal()">‚úï</div>
                </div>
                <div class="pdf-modal-body">
                    <div class="pdf-page-container">
                        <canvas id="pdfPageCanvas" class="pdf-page-canvas"></canvas>
                    </div>
                </div>
                <div class="pdf-modal-footer">
                    <div class="pdf-nav-buttons">
                        <button class="pdf-nav-btn" id="prevPageBtn" onclick="navigatePage(-1)">‚óÑ Previous</button>
                        <button class="pdf-nav-btn" id="nextPageBtn" onclick="navigatePage(1)">Next ‚ñ∫</button>
                    </div>
                    <button class="pdf-open-btn" onclick="openFullPdf()">Open Full PDF</button>
                </div>
            </div>
        </div>
        
        <!-- Dashboard Modal -->
        <div class="dashboard-modal" id="dashboardModal">
            <div class="dashboard-content">
                <div class="dashboard-header">
                    <div class="dashboard-title">Research Projects</div>
                    <div class="pdf-modal-close" onclick="closeDashboard()">‚úï</div>
                </div>
                <div class="dashboard-body" id="dashboardBody">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìÇ</div>
                        <div>No saved projects yet. Start by uploading documents!</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Research Assistant Panel -->
        <div class="assistant-panel" id="assistantPanel">
            <div class="assistant-header">
                <div>
                    <div class="assistant-title">ü§ñ Research Assistant</div>
                    <div class="assistant-status" id="assistantStatus">Ready ‚Ä¢ <span id="projectContext">No project loaded</span></div>
                </div>
                <div class="assistant-close" onclick="toggleAssistant()">‚úï</div>
            </div>
            
            <div class="assistant-chat" id="assistantChat">
                <div class="assistant-message message-assistant">
                    <div class="message-label">ASSISTANT</div>
                    <div class="message-bubble">
                        Welcome to Research Assistant! I can help you query and analyze your project data.
                        <br><br>
                        <strong>Try asking:</strong><br>
                        ‚Ä¢ "Show me all people mentioned more than 10 times"<br>
                        ‚Ä¢ "Which organizations appear in multiple documents?"<br>
                        ‚Ä¢ "Find contexts where [person] and [location] appear together"<br>
                        ‚Ä¢ "List all entities from document X"<br>
                        ‚Ä¢ "Compare entities between documents"
                    </div>
                </div>
            </div>
            
            <div class="assistant-input-area">
                <div class="assistant-input-container">
                    <textarea 
                        class="assistant-input" 
                        id="assistantInput" 
                        placeholder="Ask a question about your data..."
                        rows="2"
                    ></textarea>
                    <button class="assistant-send-btn" id="assistantSendBtn" onclick="sendAssistantQuery()">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Glossary Panel - OPTION C -->
        <div class="assistant-panel" id="glossaryPanel">
            <div class="assistant-header">
                <div>
                    <div class="assistant-title">üìö Truth-Seeking Glossary</div>
                    <div class="assistant-status" id="glossaryStatus">0 terms loaded</div>
                </div>
                <div class="assistant-close" onclick="toggleGlossary()">‚úï</div>
            </div>
            
            <div style="padding: 20px; border-bottom: 2px solid var(--border-color); background: rgba(0, 0, 0, 0.3);">
                <input 
                    type="text" 
                    id="glossarySearch" 
                    placeholder="Search terms..." 
                    style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Share Tech Mono', monospace;"
                    oninput="filterGlossary()"
                />
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="header-btn" onclick="showAddTermDialog()" style="flex: 1; font-size: 0.9em;">+ Add Term</button>
                    <button class="header-btn" onclick="showImportGlossaryDialog()" style="flex: 1; font-size: 0.9em;">üì• Import JSON</button>
                </div>
            </div>
            
            <div class="assistant-chat" id="glossaryContent" style="padding: 20px;">
                <div style="text-align: center; color: var(--text-secondary); padding: 40px 20px;">
                    <div style="font-size: 3em; margin-bottom: 15px;">üìö</div>
                    <div>No terms in glossary yet.</div>
                    <div style="margin-top: 10px; font-size: 0.9em;">Click "Load CDC Terms" to get started,<br>or add custom terms manually.</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // ===== PROJECT DATA STRUCTURE =====
        let currentProject = {
            id: null,
            name: 'Untitled Project',
            created: null,
            modified: null,
            documents: [], // Array of {id, name, size, processed, data}
            aggregatedEntities: {
                people: [],
                organizations: [],
                places: [],
                events: []
            },
            glossary: {
                terms: [], // {term, definition, category, source, addedDate, usageCount}
                lastUpdated: null
            },
            sentenceToPage: [], // Global sentence-to-page mapping across all docs
            fullText: '' // Combined text from all documents
        };
        
        // ===== INDEXEDDB SETUP =====
        let db;
        const DB_NAME = 'ResearchHubDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'projects';
        
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        objectStore.createIndex('name', 'name', { unique: false });
                        objectStore.createIndex('modified', 'modified', { unique: false });
                    }
                };
            });
        }
        
        // Initialize DB on page load
        initDB().then(() => {
            console.log('IndexedDB initialized');
            updateCurrentProjectDisplay();
        }).catch(err => {
            console.error('Failed to initialize IndexedDB:', err);
        });
        
        // Matrix Canvas Animation
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const charsets = {
            katakana: 'ÔΩ¶ÔΩ±ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâÔæäÔæãÔæåÔæçÔæéÔæèÔæêÔæëÔæíÔæìÔæîÔæïÔæñÔæóÔæòÔæôÔæöÔæõÔæúÔæù0123456789',
            binary: '01',
            hex: '0123456789ABCDEF',
            symbols: '‚àÄ‚àÇ‚àÉ‚àÑ‚àÖ‚àÜ‚àá‚àà‚àâ‚àä‚àã‚àå‚àç‚àé‚àè‚àê‚àë‚àí‚àì‚àî‚àï‚àñ‚àó‚àò‚àô‚àö‚àõ‚àú‚àù‚àû‚àü‚à†‚à°‚à¢‚à£‚à§‚à•‚à¶‚àß‚à®‚à©‚à™‚à´‚à¨‚à≠‚àÆ‚àØ‚à∞‚à±‚à≤‚à≥',
            greek: 'ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ'
        };
        
        let currentCharset = charsets.katakana;
        let fontSize = 16;
        let columns = canvas.width / fontSize;
        let drops = Array(Math.floor(columns)).fill(1);
        let matrixEnabled = true;
        let matrixIntensity = 0.5;
        
        function drawMatrix() {
            if (!matrixEnabled) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            ctx.fillStyle = `rgba(13, 13, 13, ${0.05 * matrixIntensity})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ff41';
            ctx.font = fontSize + 'px monospace';
            
            for (let i = 0; i < drops.length; i++) {
                const text = currentCharset.charAt(Math.floor(Math.random() * currentCharset.length));
                const x = i * fontSize;
                const y = drops[i] * fontSize;
                
                ctx.globalAlpha = matrixIntensity;
                ctx.fillText(text, x, y);
                
                if (y > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        
        setInterval(drawMatrix, 33);
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            columns = canvas.width / fontSize;
            drops = Array(Math.floor(columns)).fill(1);
        });
        
        // Matrix Controls
        document.getElementById('intensitySlider').addEventListener('input', (e) => {
            matrixIntensity = e.target.value / 100;
            document.getElementById('intensityValue').textContent = e.target.value;
        });
        
        document.getElementById('brightnessSlider').addEventListener('input', (e) => {
            const brightness = e.target.value / 100;
            document.getElementById('brightnessValue').textContent = e.target.value;
            canvas.style.opacity = brightness;
        });
        
        document.getElementById('charsetSelect').addEventListener('change', (e) => {
            currentCharset = charsets[e.target.value];
        });
        
        document.getElementById('matrixToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            matrixEnabled = this.classList.contains('active');
            if (!matrixEnabled) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });
        
        // File Upload Handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const analysisSection = document.getElementById('analysisSection');
        const progressContainer = document.getElementById('progressContainer');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => isSupportedFileType(f));
            if (files.length > 0) {
                handleFiles(files);
            } else {
                alert('No supported files found. Supported types: PDF, DOCX, XLSX, TXT, MD, HTML, CSV');
            }
        });
        
        function isSupportedFileType(file) {
            const supportedTypes = [
                'application/pdf',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // docx
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // xlsx
                'application/vnd.ms-excel', // xls
                'text/plain',
                'text/markdown',
                'text/html',
                'text/csv'
            ];
            
            const supportedExtensions = ['.pdf', '.docx', '.xlsx', '.xls', '.txt', '.md', '.html', '.csv'];
            
            return supportedTypes.includes(file.type) || 
                   supportedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
        }
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const files = Array.from(e.target.files);
                handleFiles(files);
            }
        });
        
        async function handleFiles(files) {
            progressContainer.classList.add('active');
            analysisSection.style.display = 'none';
            
            const progressFill = document.getElementById('progressFill');
            const progressStatus = document.getElementById('progressStatus');
            
            try {
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const percent = Math.round((i / files.length) * 100);
                    
                    progressFill.style.width = percent + '%';
                    progressFill.textContent = percent + '%';
                    progressStatus.textContent = `Processing ${file.name} (${i + 1} of ${files.length})...`;
                    
                    await processFile(file);
                }
                
                // Processing complete
                progressFill.style.width = '100%';
                progressFill.textContent = '100%';
                progressStatus.textContent = 'Complete! Aggregating results...';
                
                // Small delay to show 100%
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Aggregate and display
                aggregateEntities();
                displayAggregatedAnalysis();
                
                progressContainer.classList.remove('active');
                analysisSection.style.display = 'block';
                
                // Mark project as modified
                currentProject.modified = new Date().toISOString();
                updateCurrentProjectDisplay();
                
            } catch (error) {
                progressStatus.textContent = `Error: ${error.message}`;
                console.error('Error processing files:', error);
            }
        }
        
        async function processFile(file) {
            const docId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Check if already processed
            if (currentProject.documents.find(d => d.name === file.name && d.size === file.size)) {
                console.log(`Skipping duplicate: ${file.name}`);
                return;
            }
            
            // Detect file type and extract accordingly
            const fileType = getFileType(file);
            let extractResult;
            let fileData = null;
            
            try {
                switch(fileType) {
                    case 'pdf':
                        const arrayBuffer = await file.arrayBuffer();
                        fileData = new Blob([arrayBuffer], { type: 'application/pdf' });
                        extractResult = await extractPDFTextFromBuffer(arrayBuffer);
                        break;
                    
                    case 'docx':
                        extractResult = await extractDOCXText(file);
                        fileData = new Blob([await file.arrayBuffer()], { type: file.type });
                        break;
                    
                    case 'xlsx':
                    case 'xls':
                        extractResult = await extractXLSXText(file);
                        fileData = new Blob([await file.arrayBuffer()], { type: file.type });
                        break;
                    
                    case 'txt':
                    case 'md':
                    case 'html':
                    case 'csv':
                        extractResult = await extractPlainText(file);
                        fileData = new Blob([await file.arrayBuffer()], { type: file.type });
                        break;
                    
                    default:
                        console.error('Unsupported file type:', fileType);
                        return;
                }
                
                const analysis = analyzeText(extractResult.text, file);
                
                // Add location tracking (page/section/row depending on file type)
                analysis.locationMap = extractResult.locationMap || extractResult.sentenceToPage || [];
                analysis.fileType = fileType;
                
                currentProject.documents.push({
                    id: docId,
                    name: file.name,
                    size: file.size,
                    type: fileType,
                    processed: new Date().toISOString(),
                    analysis: analysis,
                    fileData: fileData
                });
                
            } catch (error) {
                console.error(`Error processing ${file.name}:`, error);
                throw error;
            }
        }
        
        function getFileType(file) {
            const name = file.name.toLowerCase();
            if (name.endsWith('.pdf')) return 'pdf';
            if (name.endsWith('.docx')) return 'docx';
            if (name.endsWith('.xlsx')) return 'xlsx';
            if (name.endsWith('.xls')) return 'xls';
            if (name.endsWith('.txt')) return 'txt';
            if (name.endsWith('.md')) return 'md';
            if (name.endsWith('.html')) return 'html';
            if (name.endsWith('.csv')) return 'csv';
            return 'unknown';
        }
        
        async function extractPDFTextFromBuffer(arrayBuffer) {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';
            const sentenceToPage = [];
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                
                const pageSentences = pageText.split(/[.!?]+/).filter(s => s.trim().length > 20);
                pageSentences.forEach(sentence => {
                    sentenceToPage.push({
                        text: sentence.trim(),
                        page: i
                    });
                });
                
                fullText += pageText + '\n\n';
            }
            
            // Store for single-file viewing (legacy support)
            window.currentPDF = pdf;
            window.sentenceToPage = sentenceToPage;
            
            // Return both text and page mapping
            return {
                text: fullText,
                sentenceToPage: sentenceToPage
            };
        }
        
        function aggregateEntities() {
            // Merge entities from all documents
            const aggregated = {
                people: {},
                organizations: {},
                places: {},
                events: {}
            };
            
            currentProject.documents.forEach(doc => {
                const analysis = doc.analysis;
                
                // Aggregate each entity type
                ['people', 'organizations', 'places', 'events'].forEach(type => {
                    analysis.entities[type].forEach(entity => {
                        const key = entity.name;
                        if (!aggregated[type][key]) {
                            aggregated[type][key] = {
                                name: entity.name,
                                totalCount: 0,
                                documents: []
                            };
                        }
                        aggregated[type][key].totalCount += entity.count;
                        aggregated[type][key].documents.push({
                            docId: doc.id,
                            docName: doc.name,
                            count: entity.count
                        });
                    });
                });
            });
            
            // Convert to arrays and sort
            currentProject.aggregatedEntities = {
                people: Object.values(aggregated.people).sort((a, b) => b.totalCount - a.totalCount),
                organizations: Object.values(aggregated.organizations).sort((a, b) => b.totalCount - a.totalCount),
                places: Object.values(aggregated.places).sort((a, b) => b.totalCount - a.totalCount),
                events: Object.values(aggregated.events).sort((a, b) => b.totalCount - a.totalCount)
            };
        }
        
        function displayAggregatedAnalysis() {
            const content = document.getElementById('analysisContent');
            
            // Show export button
            const exportBtn = document.getElementById('exportProjectBtn');
            if (exportBtn) exportBtn.style.display = 'block';
            
            const totalDocs = currentProject.documents.length;
            const totalWords = currentProject.documents.reduce((sum, doc) => sum + doc.analysis.stats.wordCount, 0);
            const totalSentences = currentProject.documents.reduce((sum, doc) => sum + doc.analysis.stats.sentenceCount, 0);
            
            let html = '<div class="section-title">Project Statistics</div>';
            html += '<div class="stats-grid">';
            html += `<div class="stat-item"><div class="stat-label">Documents</div><div class="stat-value">${totalDocs}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Total Words</div><div class="stat-value">${totalWords.toLocaleString()}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Total Sentences</div><div class="stat-value">${totalSentences}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Unique People</div><div class="stat-value">${currentProject.aggregatedEntities.people.length}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Unique Organizations</div><div class="stat-value">${currentProject.aggregatedEntities.organizations.length}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Unique Locations</div><div class="stat-value">${currentProject.aggregatedEntities.places.length}</div></div>`;
            html += '</div>';
            
            // Entity Categories
            html += '<div class="section-title">Aggregated Entity Analysis</div>';
            html += '<div class="entity-categories">';
            
            if (currentProject.aggregatedEntities.people.length > 0) {
                html += createAggregatedEntityCategory('People', currentProject.aggregatedEntities.people, 'person');
            }
            
            if (currentProject.aggregatedEntities.organizations.length > 0) {
                html += createAggregatedEntityCategory('Organizations', currentProject.aggregatedEntities.organizations, 'organization');
            }
            
            if (currentProject.aggregatedEntities.places.length > 0) {
                html += createAggregatedEntityCategory('Locations', currentProject.aggregatedEntities.places, 'location');
            }
            
            if (currentProject.aggregatedEntities.events.length > 0) {
                html += createAggregatedEntityCategory('Events', currentProject.aggregatedEntities.events, 'event');
            }
            
            html += '</div>';
            
            content.innerHTML = html;
            
            // Store for context lookup
            window.currentAnalysis = {
                aggregated: true,
                project: currentProject
            };
            
            // Add click handlers
            document.querySelectorAll('.entity-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entityName = item.dataset.entity;
                    const entityType = item.dataset.type;
                    showAggregatedEntityContext(entityName, entityType);
                });
            });
            
            document.querySelectorAll('.show-more').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const category = btn.dataset.category;
                    expandFullList(category);
                });
            });
        }
        
        function createAggregatedEntityCategory(title, entities, type) {
            const topFive = entities.slice(0, 5);
            const nextFive = entities.slice(5, 10);
            const total = entities.length;
            
            let html = '<div class="entity-category">';
            html += `<div class="category-header">`;
            html += `<span>${title}</span>`;
            html += `<span class="category-count">${total} found</span>`;
            html += `</div>`;
            
            html += '<ul class="entity-list">';
            topFive.forEach(entity => {
                const docList = entity.documents.map(d => d.docName).join(', ');
                html += `<li class="entity-item" data-entity="${escapeHtml(entity.name)}" data-type="${type}" title="${docList}">`;
                html += `<span class="entity-name">${escapeHtml(entity.name)}</span>`;
                html += `<span class="entity-count">${entity.totalCount}√ó (${entity.documents.length} docs)</span>`;
                html += `</li>`;
            });
            html += '</ul>';
            
            if (nextFive.length > 0) {
                html += '<div class="entity-expanded">';
                html += '<ul class="entity-list">';
                nextFive.forEach(entity => {
                    const docList = entity.documents.map(d => d.docName).join(', ');
                    html += `<li class="entity-item" data-entity="${escapeHtml(entity.name)}" data-type="${type}" title="${docList}">`;
                    html += `<span class="entity-name">${escapeHtml(entity.name)}</span>`;
                    html += `<span class="entity-count">${entity.totalCount}√ó (${entity.documents.length} docs)</span>`;
                    html += `</li>`;
                });
                html += '</ul>';
                html += '</div>';
            }
            
            if (total > 10) {
                html += `<div class="show-more" data-category="${type}" data-total="${total}">+${total - 10} more entities (click to expand)</div>`;
            }
            
            html += '</div>';
            return html;
        }
        
        function showAggregatedEntityContext(entityName, entityType) {
            // Map single type to plural for lookup
            const typeMap = {
                'person': 'people',
                'organization': 'organizations',
                'location': 'places',
                'event': 'events'
            };
            
            const pluralType = typeMap[entityType];
            
            // Find entity in aggregated data
            const entityData = currentProject.aggregatedEntities[pluralType].find(e => e.name === entityName);
            if (!entityData) {
                console.error('Entity not found:', entityName, pluralType);
                return;
            }
            
            // Gather contexts from all documents
            const allContexts = [];
            
            entityData.documents.forEach(docRef => {
                const doc = currentProject.documents.find(d => d.id === docRef.docId);
                if (!doc) return;
                
                const analysis = doc.analysis;
                const pattern = createVariationPattern(entityName);
                
                analysis.sentences.forEach((sentence, index) => {
                    if (pattern.test(sentence)) {
                        let locationInfo = 'Unknown';
                        let locationDisplay = 'Unknown';
                        
                        // Determine file type (backward compatibility)
                        const fileType = doc.type || 'pdf'; // Default to PDF for old projects
                        
                        // Get location based on file type
                        if (analysis.locationMap && analysis.locationMap[index]) {
                            const loc = analysis.locationMap[index];
                            locationInfo = loc;
                            
                            switch(fileType) {
                                case 'pdf':
                                    locationDisplay = `Page ${loc.page || loc}`;
                                    locationInfo = loc.page || loc;
                                    break;
                                case 'docx':
                                    locationDisplay = `Section ${loc.section || loc}`;
                                    break;
                                case 'xlsx':
                                case 'xls':
                                    locationDisplay = `${loc.sheet || 'Sheet'}, Row ${loc.row || '?'}`;
                                    break;
                                case 'txt':
                                case 'md':
                                case 'html':
                                    locationDisplay = `Line ${loc.line || loc}`;
                                    break;
                                case 'csv':
                                    locationDisplay = `Row ${loc.row || '?'}`;
                                    break;
                                default:
                                    locationDisplay = String(loc);
                            }
                        } else if (analysis.sentenceToPage && analysis.sentenceToPage[index]) {
                            // Backward compatibility for old PDF projects
                            const pageNum = analysis.sentenceToPage[index].page;
                            locationInfo = pageNum;
                            locationDisplay = `Page ${pageNum}`;
                        }
                        
                        const highlighted = sentence.replace(pattern, (match) => {
                            return `<span class="context-highlight">${match}</span>`;
                        });
                        
                        allContexts.push({
                            docId: doc.id,
                            docName: doc.name,
                            docType: fileType,
                            index: index + 1,
                            location: locationInfo,
                            locationDisplay: locationDisplay,
                            text: highlighted.trim()
                        });
                    }
                });
            });
            
            // Display contexts
            let contextSection = document.getElementById('contextSection');
            if (!contextSection) {
                contextSection = document.createElement('div');
                contextSection.id = 'contextSection';
                contextSection.className = 'context-section';
                document.getElementById('analysisContent').appendChild(contextSection);
            }
            
            let html = '<div class="context-header">';
            html += `<div class="context-title">${escapeHtml(entityName)} - ${allContexts.length} mentions across ${entityData.documents.length} documents</div>`;
            html += '<div class="context-close" onclick="document.getElementById(\'contextSection\').remove()">‚úï</div>';
            html += '</div>';
            
            if (allContexts.length > 0) {
                let currentDoc = null;
                allContexts.forEach((context, idx) => {
                    if (currentDoc !== context.docName) {
                        if (currentDoc !== null) html += '</div>';
                        const fileIcon = getFileIcon(context.docType);
                        html += `<div style="margin-top: 20px; padding: 10px; background: rgba(0, 255, 65, 0.05); border-left: 3px solid var(--matrix-green);"><strong>${fileIcon} ${escapeHtml(context.docName)} (${context.docType.toUpperCase()})</strong></div>`;
                        currentDoc = context.docName;
                    }
                    
                    html += `<div class="context-item clickable-context" data-doc-id="${context.docId}" data-location='${JSON.stringify(context.location)}' style="cursor: pointer;" title="Click to view location">`;
                    html += `<div style="font-size: 0.8em; color: var(--text-secondary); margin-bottom: 5px;">`;
                    html += `Context #${context.index} | ${context.locationDisplay} | <span style="color: var(--matrix-green);">Click to view</span>`;
                    html += `</div>`;
                    html += context.text;
                    html += `</div>`;
                });
            } else {
                html += '<div class="context-item">No context found.</div>';
            }
            
            contextSection.innerHTML = html;
            
            // Add click handlers to all clickable contexts
            contextSection.querySelectorAll('.clickable-context').forEach(item => {
                item.addEventListener('click', function() {
                    const docId = this.dataset.docId;
                    const location = JSON.parse(this.dataset.location);
                    showPdfPageForDoc(docId, location);
                });
            });
            
            contextSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function getFileIcon(fileType) {
            const icons = {
                'pdf': 'üìÑ',
                'docx': 'üìù',
                'xlsx': 'üìä',
                'xls': 'üìä',
                'txt': 'üìÉ',
                'md': 'üìã',
                'html': 'üåê',
                'csv': 'üìà'
            };
            return icons[fileType] || 'üìÅ';
        }
        
        async function extractPDFText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await extractPDFTextFromBuffer(arrayBuffer);
            return result.text;
        }
        
        // ===== DOCX EXTRACTION =====
        async function extractDOCXText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
            const text = result.value;
            
            // Create location map by paragraph/section
            const paragraphs = text.split(/\n\n+/);
            const locationMap = [];
            let currentPos = 0;
            
            paragraphs.forEach((para, index) => {
                if (para.trim().length > 20) {
                    const sentences = para.split(/[.!?]+/).filter(s => s.trim().length > 20);
                    sentences.forEach(sentence => {
                        locationMap.push({
                            text: sentence.trim(),
                            section: index + 1,
                            type: 'paragraph'
                        });
                    });
                }
                currentPos += para.length + 2;
            });
            
            return {
                text: text,
                locationMap: locationMap
            };
        }
        
        // ===== XLSX EXTRACTION =====
        async function extractXLSXText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            
            let fullText = '';
            const locationMap = [];
            
            workbook.SheetNames.forEach((sheetName, sheetIndex) => {
                const sheet = workbook.Sheets[sheetName];
                const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
                
                fullText += `\n\n=== Sheet: ${sheetName} ===\n\n`;
                
                // Extract cell by cell
                for (let row = range.s.r; row <= range.e.r; row++) {
                    let rowText = '';
                    for (let col = range.s.c; col <= range.e.c; col++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                        const cell = sheet[cellAddress];
                        if (cell && cell.v) {
                            const value = String(cell.v).trim();
                            if (value.length > 0) {
                                rowText += value + ' ';
                                
                                // Track cells with substantial text (potential entities)
                                if (value.length > 3 && isNaN(value)) {
                                    locationMap.push({
                                        text: value,
                                        sheet: sheetName,
                                        row: row + 1,
                                        col: col + 1,
                                        cell: cellAddress,
                                        type: 'cell'
                                    });
                                }
                            }
                        }
                    }
                    if (rowText.trim().length > 0) {
                        fullText += rowText.trim() + '\n';
                    }
                }
            });
            
            return {
                text: fullText,
                locationMap: locationMap
            };
        }
        
        // ===== PLAIN TEXT / MD / HTML / CSV EXTRACTION =====
        async function extractPlainText(file) {
            const text = await file.text();
            
            // For CSV, parse structure
            if (file.name.toLowerCase().endsWith('.csv')) {
                return extractCSVText(text);
            }
            
            // For HTML, strip tags
            if (file.name.toLowerCase().endsWith('.html')) {
                const stripped = text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
                return extractTextWithLineNumbers(stripped);
            }
            
            // For TXT/MD, use line numbers
            return extractTextWithLineNumbers(text);
        }
        
        function extractTextWithLineNumbers(text) {
            const lines = text.split('\n');
            const locationMap = [];
            
            lines.forEach((line, index) => {
                if (line.trim().length > 20) {
                    const sentences = line.split(/[.!?]+/).filter(s => s.trim().length > 20);
                    sentences.forEach(sentence => {
                        locationMap.push({
                            text: sentence.trim(),
                            line: index + 1,
                            type: 'line'
                        });
                    });
                }
            });
            
            return {
                text: text,
                locationMap: locationMap
            };
        }
        
        function extractCSVText(csvText) {
            const lines = csvText.split('\n');
            const locationMap = [];
            let fullText = '';
            
            lines.forEach((line, index) => {
                const cells = line.split(',').map(c => c.trim().replace(/^"|"$/g, ''));
                const rowText = cells.join(' ');
                fullText += rowText + '\n';
                
                cells.forEach((cell, colIndex) => {
                    if (cell.length > 3 && isNaN(cell)) {
                        locationMap.push({
                            text: cell,
                            row: index + 1,
                            col: colIndex + 1,
                            type: 'csv-cell'
                        });
                    }
                });
            });
            
            return {
                text: fullText,
                locationMap: locationMap
            };
        }
        
        function analyzeText(text, file) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 20);
            const words = text.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            
            // Extract entities using pattern-based approach
            const people = extractPeople(text);
            const organizations = extractOrganizations(text);
            const places = extractPlaces(text);
            const events = extractEvents(text);
            
            return {
                stats: {
                    pageCount: Math.ceil(text.length / 3000),
                    wordCount: words.length,
                    characterCount: text.length,
                    sentenceCount: sentences.length,
                    peopleCount: people.length,
                    orgCount: organizations.length,
                    locationCount: places.length,
                    eventCount: events.length
                },
                entities: {
                    people: people.slice(0, 50),
                    organizations: organizations.slice(0, 50),
                    places: places.slice(0, 50),
                    events: events.slice(0, 50)
                },
                fullText: text,
                sentences: sentences
            };
        }
        
        function extractPeople(text) {
            // Pattern: Title + First + Last or First + Last
            const titles = ['Mr', 'Mrs', 'Ms', 'Dr', 'Prof', 'Sir', 'Dame', 'Lord', 'Lady', 'Judge', 'Justice'];
            const titlePattern = titles.join('|');
            
            // Match: "Title FirstName LastName" or "FirstName LastName"
            const pattern = new RegExp(
                `\\b(?:(?:${titlePattern})\\.?\\s+)?([A-Z][a-z]+(?:-[A-Z][a-z]+)?)\\s+([A-Z][a-z]+(?:-[A-Z][a-z]+)?)\\b`,
                'g'
            );
            
            const matches = {};
            let match;
            
            // Enhanced blacklist - OPTION B IMPLEMENTATION
            const blacklist = [
                // Original terms
                'District Court', 'Protective Order', 'United States', 'New York',
                'New Jersey', 'Supreme Court', 'Circuit Court', 'Federal Court',
                'White House', 'State Department', 'Justice Department', 'District Attorney',
                'Attorney General', 'United Kingdom', 'Los Angeles', 'San Francisco',
                'New Mexico', 'New Hampshire', 'North Carolina', 'South Carolina',
                'West Virginia', 'Rhode Island', 'Puerto Rico', 'Costa Rica',
                
                // NEW - Legal/Court Terms (OPTION B)
                'Second Circuit', 'Third Circuit', 'Ninth Circuit', 'Eleventh Circuit',
                'Court Reporting', 'Southern Reporting', 'Court Reporter', 'Court Services',
                'Filed Under', 'Sealed Exhibit', 'Undisputed Fact', 'Disputed Fact',
                'Case Document', 'Exhibit Number', 'Page Filed', 'Document Filed',
                'Confidential Confidential', 'Deposition Exhibit', 'Trial Exhibit',
                'Victims Refuse', 'Filed Sealed', 'Under Seal', 'Sealed Matter',
                
                // NEW - Geographic False Positives (OPTION B)
                'Palm Beach', 'Royal Palm', 'West Palm', 'Palm Springs',
                'Virgin Islands', 'Rhode Island', 'Long Island', 'Staten Island',
                'North Dakota', 'South Dakota', 'North Carolina', 'South Carolina',
                'New Mexico', 'New Hampshire', 'New York', 'New Jersey',
                'Los Angeles', 'San Francisco', 'San Diego', 'San Antonio',
                'Santa Fe', 'Santa Barbara', 'Santa Clara', 'Santa Monica',
                
                // NEW - Formatting Artifacts (OPTION B)
                'Document Page', 'Filed Date', 'Case Number', 'Docket Number',
                'Page Number', 'Line Number', 'Exhibit Letter', 'Document Number',
                
                // NEW - Common Court Phrases (OPTION B)
                'Protective Order', 'Temporary Restraining', 'Preliminary Injunction',
                'Summary Judgment', 'Motion Filed', 'Brief Filed', 'Order Entered'
            ];
            
            while ((match = pattern.exec(text)) !== null) {
                const fullName = match[0].trim();
                
                // Filter criteria:
                // 1. Not in blacklist
                // 2. Has at least 2 words
                // 3. Doesn't end with common place/org words
                // 4. Second word isn't a state/country/org keyword
                const secondWord = fullName.split(' ').slice(-1)[0];
                const endsWithBadWord = /Court|Order|States|York|Department|Office|Agency|Bureau|District|County|City|Street|Avenue|Road|Island/.test(secondWord);
                
                if (!blacklist.includes(fullName) && 
                    fullName.split(' ').length >= 2 && 
                    !endsWithBadWord &&
                    fullName.length > 5) {
                    matches[fullName] = (matches[fullName] || 0) + 1;
                }
            }
            
            return Object.entries(matches)
                .map(([name, count]) => ({ name, count, variations: [name] }))
                .filter(e => e.count >= 2) // Only show people mentioned at least twice
                .sort((a, b) => b.count - a.count);
        }
        
        function extractOrganizations(text) {
            // Common org suffixes and keywords
            const orgSuffixes = [
                'Inc', 'Corp', 'Corporation', 'Company', 'Co', 'Ltd', 'LLC', 'LLP',
                'Foundation', 'Institute', 'Association', 'Organization', 'Agency',
                'Department', 'Bureau', 'Commission', 'Authority', 'Group', 'Holdings',
                'Technologies', 'Systems', 'Services', 'Solutions', 'International'
            ];
            
            const matches = {};
            
            // Pattern 1: Capitalized words followed by org suffix
            orgSuffixes.forEach(suffix => {
                const pattern = new RegExp(
                    `\\b([A-Z][A-Za-z0-9&\\s-]{2,40}?)\\s+${suffix}\\.?\\b`,
                    'g'
                );
                
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const org = match[0].trim();
                    const normalized = normalizeEntity(org);
                    if (normalized.length > 3) { // Minimum length filter
                        matches[normalized] = (matches[normalized] || 0) + 1;
                    }
                }
            });
            
            // Pattern 2: Well-known organizations and government agencies (full names)
            const knownOrgs = [
                'FBI', 'CIA', 'NSA', 'DEA', 'ATF', 'DHS', 'DOJ', 'SEC', 'FTC', 'FDA',
                'Federal Bureau', 'Department of Justice', 'Securities and Exchange',
                'Internal Revenue Service', 'Social Security'
            ];
            
            knownOrgs.forEach(org => {
                const pattern = new RegExp(`\\b${org}\\b`, 'gi');
                const orgMatches = text.match(pattern);
                if (orgMatches) {
                    matches[org] = orgMatches.length;
                }
            });
            
            // Pattern 3: Multi-word capitalized organizations (without suffix)
            // e.g., "Palm Beach County", "Southern District"
            const multiWordPattern = /\b([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)\s+(?:District|County|Department|Office|Bureau|Agency|Commission)\b/g;
            let match;
            while ((match = multiWordPattern.exec(text)) !== null) {
                const org = match[0].trim();
                matches[org] = (matches[org] || 0) + 1;
            }
            
            return Object.entries(matches)
                .map(([name, count]) => ({ name, count, variations: [name] }))
                .filter(e => e.count >= 2) // Only show orgs mentioned at least twice
                .sort((a, b) => b.count - a.count);
        }
        
        function extractPlaces(text) {
            // Common place indicators
            const placeKeywords = [
                'City', 'County', 'State', 'Province', 'Country', 'Island', 'Islands',
                'Street', 'Avenue', 'Road', 'Boulevard', 'Drive', 'Lane',
                'District', 'Region', 'Territory', 'Republic', 'Kingdom', 'Empire'
            ];
            
            const matches = {};
            
            // Pattern 1: Place name + keyword
            placeKeywords.forEach(keyword => {
                const pattern = new RegExp(
                    `\\b([A-Z][A-Za-z\\s-]{2,30}?)\\s+${keyword}\\b`,
                    'g'
                );
                
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const place = match[0].trim();
                    matches[place] = (matches[place] || 0) + 1;
                }
            });
            
            // Pattern 2: US States (common ones)
            const usStates = [
                'Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado',
                'Connecticut', 'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho',
                'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky', 'Louisiana',
                'Maine', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota',
                'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada',
                'New Hampshire', 'New Jersey', 'New Mexico', 'New York',
                'North Carolina', 'North Dakota', 'Ohio', 'Oklahoma', 'Oregon',
                'Pennsylvania', 'Rhode Island', 'South Carolina', 'South Dakota',
                'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia', 'Washington',
                'West Virginia', 'Wisconsin', 'Wyoming'
            ];
            
            usStates.forEach(state => {
                const pattern = new RegExp(`\\b${state}\\b`, 'gi');
                const stateMatches = text.match(pattern);
                if (stateMatches) {
                    matches[state] = stateMatches.length;
                }
            });
            
            // Pattern 3: Major world cities/countries
            const majorLocations = [
                'London', 'Paris', 'Berlin', 'Rome', 'Madrid', 'Moscow', 'Beijing',
                'Tokyo', 'Seoul', 'Sydney', 'Toronto', 'Mexico City', 'Dubai',
                'United States', 'United Kingdom', 'Canada', 'Australia', 'China',
                'Japan', 'Germany', 'France', 'Italy', 'Spain', 'Russia', 'India',
                'Brazil', 'Mexico', 'Israel', 'Egypt', 'South Africa'
            ];
            
            majorLocations.forEach(location => {
                const pattern = new RegExp(`\\b${location}\\b`, 'gi');
                const locMatches = text.match(pattern);
                if (locMatches) {
                    matches[location] = locMatches.length;
                }
            });
            
            return Object.entries(matches)
                .map(([name, count]) => ({ name, count, variations: [name] }))
                .sort((a, b) => b.count - a.count);
        }
        
        function isCommonPhrase(text) {
            const common = [
                'Thank You', 'United States', 'New York', 'Los Angeles',
                'Supreme Court', 'White House', 'District Court'
            ];
            return common.includes(text);
        }
        
        function isCommonAcronym(text) {
            const common = ['THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE', 'OUR', 'OUT', 'DAY', 'GET', 'HAS', 'HIM', 'HIS', 'HOW', 'ITS', 'MAY', 'NEW', 'NOW', 'OLD', 'SEE', 'TWO', 'WAY', 'WHO', 'BOY', 'DID', 'ITS', 'LET', 'PUT', 'SAY', 'SHE', 'TOO', 'USE'];
            return common.includes(text);
        }
        
        function fallbackAnalysis(text) {
            // This function is no longer needed but keeping for compatibility
            return analyzeText(text);
        }
        
        function extractEvents(text) {
            const eventKeywords = [
                'operation', 'project', 'program', 'initiative', 'exercise',
                'summit', 'conference', 'meeting', 'treaty', 'agreement',
                'act', 'case', 'investigation', 'incident', 'event'
            ];
            
            const events = {};
            const sentences = text.split(/[.!?]+/);
            
            sentences.forEach(sentence => {
                eventKeywords.forEach(keyword => {
                    const pattern = new RegExp(`\\b(${keyword}\\s+[A-Z][\\w\\s]{2,30})`, 'gi');
                    const matches = sentence.match(pattern);
                    
                    if (matches) {
                        matches.forEach(match => {
                            const normalized = match.trim();
                            if (normalized.length > 10 && normalized.length < 50) {
                                events[normalized] = (events[normalized] || 0) + 1;
                            }
                        });
                    }
                });
            });
            
            return Object.entries(events)
                .map(([name, count]) => ({ name, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        function normalizeEntity(entity) {
            // Remove common suffixes and clean up
            return entity
                .trim()
                .replace(/\s+(Inc|Corp|Co|Ltd|LLC|Corporation|Company)\.?$/i, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        function createVariationPattern(entity) {
            // Escape special regex characters
            const escaped = entity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            // Match the entity with optional suffixes
            return new RegExp(`\\b${escaped}(?:\\s+(?:Inc|Corp|Co|Ltd|LLC|Corporation|Company|Technologies))?\\b`, 'gi');
        }
        
        function displayAnalysis(analysis) {
            const content = document.getElementById('analysisContent');
            
            let html = '<div class="section-title">Document Statistics</div>';
            html += '<div class="stats-grid">';
            html += `<div class="stat-item"><div class="stat-label">Pages</div><div class="stat-value">${analysis.stats.pageCount}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Words</div><div class="stat-value">${analysis.stats.wordCount.toLocaleString()}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Characters</div><div class="stat-value">${analysis.stats.characterCount.toLocaleString()}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Sentences</div><div class="stat-value">${analysis.stats.sentenceCount}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">People Found</div><div class="stat-value">${analysis.stats.peopleCount}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Organizations</div><div class="stat-value">${analysis.stats.orgCount}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Locations</div><div class="stat-value">${analysis.stats.locationCount}</div></div>`;
            html += `<div class="stat-item"><div class="stat-label">Events</div><div class="stat-value">${analysis.stats.eventCount}</div></div>`;
            html += '</div>';
            
            // Entity Categories
            html += '<div class="section-title">Entity Analysis</div>';
            html += '<div class="entity-categories">';
            
            // People
            if (analysis.entities.people.length > 0) {
                html += createEntityCategory('People', analysis.entities.people, 'person');
            }
            
            // Organizations
            if (analysis.entities.organizations.length > 0) {
                html += createEntityCategory('Organizations', analysis.entities.organizations, 'organization');
            }
            
            // Locations
            if (analysis.entities.places.length > 0) {
                html += createEntityCategory('Locations', analysis.entities.places, 'location');
            }
            
            // Events
            if (analysis.entities.events.length > 0) {
                html += createEntityCategory('Events', analysis.entities.events, 'event');
            }
            
            html += '</div>';
            
            content.innerHTML = html;
            
            // Store analysis data for context lookup
            window.currentAnalysis = analysis;
            
            // Add click handlers for entities
            document.querySelectorAll('.entity-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entityName = item.dataset.entity;
                    const entityType = item.dataset.type;
                    showEntityContext(entityName, entityType);
                });
            });
            
            // Add click handlers for "show more" buttons
            document.querySelectorAll('.show-more').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const category = btn.dataset.category;
                    expandFullList(category);
                });
            });
        }
        
        function createEntityCategory(title, entities, type) {
            const topFive = entities.slice(0, 5);
            const nextFive = entities.slice(5, 10);
            const total = entities.length;
            
            let html = '<div class="entity-category">';
            html += `<div class="category-header">`;
            html += `<span>${title}</span>`;
            html += `<span class="category-count">${total} found</span>`;
            html += `</div>`;
            
            // Top 5 (always visible)
            html += '<ul class="entity-list">';
            topFive.forEach(entity => {
                html += `<li class="entity-item" data-entity="${escapeHtml(entity.name)}" data-type="${type}">`;
                html += `<span class="entity-name">${escapeHtml(entity.name)}</span>`;
                html += `<span class="entity-count">${entity.count}√ó</span>`;
                html += `</li>`;
            });
            html += '</ul>';
            
            // Next 5 (visible on hover)
            if (nextFive.length > 0) {
                html += '<div class="entity-expanded">';
                html += '<ul class="entity-list">';
                nextFive.forEach(entity => {
                    html += `<li class="entity-item" data-entity="${escapeHtml(entity.name)}" data-type="${type}">`;
                    html += `<span class="entity-name">${escapeHtml(entity.name)}</span>`;
                    html += `<span class="entity-count">${entity.count}√ó</span>`;
                    html += `</li>`;
                });
                html += '</ul>';
                html += '</div>';
            }
            
            // Show more indicator
            if (total > 10) {
                html += `<div class="show-more" data-category="${type}" data-total="${total}">+${total - 10} more entities (click to expand)</div>`;
            }
            
            html += '</div>';
            return html;
        }
        
        function expandFullList(category) {
            // Find the category element
            const categoryElements = document.querySelectorAll('.entity-category');
            let targetCategory = null;
            
            categoryElements.forEach(elem => {
                const showMore = elem.querySelector('.show-more');
                if (showMore && showMore.dataset.category === category) {
                    targetCategory = elem;
                }
            });
            
            if (!targetCategory) return;
            
            // Get all entities for this category
            let allEntities = [];
            
            // Check if we're in aggregated mode
            if (window.currentAnalysis && window.currentAnalysis.aggregated) {
                const typeMap = {
                    'person': 'people',
                    'organization': 'organizations',
                    'location': 'places',
                    'event': 'events'
                };
                allEntities = currentProject.aggregatedEntities[typeMap[category]] || [];
            } else {
                const analysis = window.currentAnalysis;
                const typeMap = {
                    'person': 'people',
                    'organization': 'organizations',
                    'location': 'places',
                    'event': 'events'
                };
                allEntities = analysis.entities[typeMap[category]] || [];
            }
            
            // Build full list HTML
            const remaining = allEntities.slice(10);
            let html = '<div class="entity-list entity-full-list">';
            remaining.forEach(entity => {
                // Check if aggregated
                if (window.currentAnalysis && window.currentAnalysis.aggregated) {
                    const docList = entity.documents.map(d => d.docName).join(', ');
                    html += `<li class="entity-item" data-entity="${escapeHtml(entity.name)}" data-type="${category}" title="${docList}">`;
                    html += `<span class="entity-name">${escapeHtml(entity.name)}</span>`;
                    html += `<span class="entity-count">${entity.totalCount}√ó (${entity.documents.length} docs)</span>`;
                    html += `</li>`;
                } else {
                    html += `<li class="entity-item" data-entity="${escapeHtml(entity.name)}" data-type="${category}">`;
                    html += `<span class="entity-name">${escapeHtml(entity.name)}</span>`;
                    html += `<span class="entity-count">${entity.count}√ó</span>`;
                    html += `</li>`;
                }
            });
            html += '</div>';
            
            // Replace the show-more section
            const showMore = targetCategory.querySelector('.show-more');
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            showMore.replaceWith(tempDiv.firstChild);
            
            // Add click handlers to new items
            targetCategory.querySelectorAll('.entity-full-list .entity-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entityName = item.dataset.entity;
                    const entityType = item.dataset.type;
                    
                    // Check if aggregated
                    if (window.currentAnalysis && window.currentAnalysis.aggregated) {
                        showAggregatedEntityContext(entityName, entityType);
                    } else {
                        showEntityContext(entityName, entityType);
                    }
                });
            });
        }
        
        function showEntityContext(entityName, entityType) {
            const analysis = window.currentAnalysis;
            if (!analysis) return;
            
            // Find all sentences containing this entity (with variations)
            const contexts = [];
            const pattern = createVariationPattern(entityName);
            
            analysis.sentences.forEach((sentence, index) => {
                if (pattern.test(sentence)) {
                    // Find page number for this sentence
                    let pageNum = 'Unknown';
                    if (window.sentenceToPage && window.sentenceToPage[index]) {
                        pageNum = window.sentenceToPage[index].page;
                    }
                    
                    // Highlight the entity in the sentence
                    const highlighted = sentence.replace(pattern, (match) => {
                        return `<span class="context-highlight">${match}</span>`;
                    });
                    contexts.push({
                        index: index + 1,
                        page: pageNum,
                        text: highlighted.trim()
                    });
                }
            });
            
            // Check if context section already exists
            let contextSection = document.getElementById('contextSection');
            if (!contextSection) {
                contextSection = document.createElement('div');
                contextSection.id = 'contextSection';
                contextSection.className = 'context-section';
                document.getElementById('analysisContent').appendChild(contextSection);
            }
            
            // Build context display
            let html = '<div class="context-header">';
            html += `<div class="context-title">${escapeHtml(entityName)} - ${contexts.length} mentions</div>`;
            html += '<div class="context-close" onclick="document.getElementById(\'contextSection\').remove()">‚úï</div>';
            html += '</div>';
            
            if (contexts.length > 0) {
                contexts.forEach(context => {
                    html += `<div class="context-item" onclick="showPdfPage(${context.page})" style="cursor: pointer;" title="Click to view page ${context.page}">`;
                    html += `<div style="font-size: 0.8em; color: var(--text-secondary); margin-bottom: 5px;">`;
                    html += `Context #${context.index} | Page ${context.page} | <span style="color: var(--matrix-green);">Click to view PDF</span>`;
                    html += `</div>`;
                    html += context.text;
                    html += `</div>`;
                });
            } else {
                html += '<div class="context-item">No context found.</div>';
            }
            
            contextSection.innerHTML = html;
            contextSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ===== PROJECT MANAGEMENT FUNCTIONS =====
        
        function updateCurrentProjectDisplay() {
            const display = document.getElementById('currentProjectDisplay');
            if (currentProject.documents.length > 0) {
                display.textContent = `Current Project: ${currentProject.name} | ${currentProject.documents.length} documents | ${currentProject.aggregatedEntities.people.length + currentProject.aggregatedEntities.organizations.length + currentProject.aggregatedEntities.places.length + currentProject.aggregatedEntities.events.length} entities`;
            } else {
                display.textContent = `Current Project: ${currentProject.name} | No documents yet`;
            }
        }
        
        async function saveProject() {
            if (currentProject.documents.length === 0) {
                alert('No documents to save. Please upload some PDFs first.');
                return;
            }
            
            // Prompt for project name if it's "Untitled Project"
            if (currentProject.name === 'Untitled Project' || !currentProject.id) {
                const name = prompt('Enter a name for this project:', currentProject.name);
                if (!name || name.trim() === '') return;
                currentProject.name = name.trim();
                currentProject.id = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                currentProject.created = new Date().toISOString();
            }
            
            currentProject.modified = new Date().toISOString();
            
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                await objectStore.put(currentProject);
                
                alert(`Project "${currentProject.name}" saved successfully!`);
                updateCurrentProjectDisplay();
                
                // Save to localStorage as "last session"
                localStorage.setItem('lastSessionId', currentProject.id);
            } catch (error) {
                console.error('Error saving project:', error);
                alert('Failed to save project: ' + error.message);
            }
        }
        
        async function loadProject(projectId) {
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.get(projectId);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        if (request.result) {
                            currentProject = request.result;
                            displayAggregatedAnalysis();
                            updateCurrentProjectDisplay();
                            analysisSection.style.display = 'block';
                            resolve(request.result);
                        } else {
                            reject(new Error('Project not found'));
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Error loading project:', error);
                alert('Failed to load project: ' + error.message);
            }
        }
        
        async function loadLastSession() {
            const lastId = localStorage.getItem('lastSessionId');
            if (!lastId) {
                alert('No previous session found.');
                return;
            }
            
            try {
                await loadProject(lastId);
                alert(`Loaded project: ${currentProject.name}`);
            } catch (error) {
                alert('Failed to load last session.');
            }
        }
        
        function newProject() {
            if (currentProject.documents.length > 0) {
                const confirm = window.confirm('Starting a new project will open a fresh hub in a new window. Continue?');
                if (!confirm) return;
            }
            
            // Open new window with current URL
            window.open(window.location.href, '_blank');
        }
        
        async function showDashboard() {
            const modal = document.getElementById('dashboardModal');
            const body = document.getElementById('dashboardBody');
            
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.getAll();
                
                request.onsuccess = () => {
                    const projects = request.result;
                    
                    if (projects.length === 0) {
                        body.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">üìÇ</div>
                                <div>No saved projects yet. Start by uploading documents!</div>
                            </div>
                        `;
                    } else {
                        let html = '<ul class="project-list">';
                        projects.sort((a, b) => new Date(b.modified) - new Date(a.modified));
                        
                        projects.forEach(project => {
                            const modifiedDate = new Date(project.modified).toLocaleString();
                            const totalEntities = project.aggregatedEntities.people.length + 
                                                project.aggregatedEntities.organizations.length + 
                                                project.aggregatedEntities.places.length + 
                                                project.aggregatedEntities.events.length;
                            
                            html += '<li class="project-item">';
                            html += `<div class="project-name">${escapeHtml(project.name)}</div>`;
                            html += `<div class="project-meta">${project.documents.length} documents | ${totalEntities} entities | Last modified: ${modifiedDate}</div>`;
                            html += '<div class="project-actions">';
                            html += `<button class="project-btn" onclick="loadProjectFromDashboard('${project.id}')">Open</button>`;
                            html += `<button class="project-btn" onclick="openProjectInNewWindow('${project.id}')">Open in New Window</button>`;
                            html += `<button class="project-btn" onclick="renameProject('${project.id}')">Rename</button>`;
                            html += `<button class="project-btn danger" onclick="deleteProject('${project.id}')">Delete</button>`;
                            html += '</div>';
                            html += '</li>';
                        });
                        html += '</ul>';
                        body.innerHTML = html;
                    }
                    
                    modal.classList.add('active');
                };
                
                request.onerror = () => {
                    alert('Failed to load projects.');
                };
            } catch (error) {
                console.error('Error showing dashboard:', error);
                alert('Failed to open dashboard: ' + error.message);
            }
        }
        
        function closeDashboard() {
            document.getElementById('dashboardModal').classList.remove('active');
        }
        
        async function loadProjectFromDashboard(projectId) {
            closeDashboard();
            await loadProject(projectId);
        }
        
        function openProjectInNewWindow(projectId) {
            const newWindow = window.open(window.location.href, '_blank');
            // Store the project ID to load in the new window
            localStorage.setItem('loadProjectOnOpen', projectId);
        }
        
        async function deleteProject(projectId) {
            const project = await getProject(projectId);
            if (!project) return;
            
            const confirm = window.confirm(`Delete project "${project.name}"? This cannot be undone.`);
            if (!confirm) return;
            
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                await objectStore.delete(projectId);
                
                alert('Project deleted successfully.');
                showDashboard(); // Refresh dashboard
            } catch (error) {
                console.error('Error deleting project:', error);
                alert('Failed to delete project: ' + error.message);
            }
        }
        
        async function renameProject(projectId) {
            const project = await getProject(projectId);
            if (!project) return;
            
            const newName = prompt('Enter new name for project:', project.name);
            if (!newName || newName.trim() === '') return;
            
            project.name = newName.trim();
            project.modified = new Date().toISOString();
            
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                await objectStore.put(project);
                
                alert('Project renamed successfully.');
                showDashboard(); // Refresh dashboard
                
                if (currentProject.id === projectId) {
                    currentProject.name = project.name;
                    updateCurrentProjectDisplay();
                }
            } catch (error) {
                console.error('Error renaming project:', error);
                alert('Failed to rename project: ' + error.message);
            }
        }
        
        async function getProject(projectId) {
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.get(projectId);
                
                return new Promise((resolve) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });
            } catch (error) {
                return null;
            }
        }
        
        // Check if we need to load a project on page load
        window.addEventListener('load', () => {
            const loadProjectId = localStorage.getItem('loadProjectOnOpen');
            if (loadProjectId) {
                localStorage.removeItem('loadProjectOnOpen');
                loadProject(loadProjectId);
            }
        });
        
        // Auto-save every 5 minutes
        setInterval(() => {
            if (currentProject.documents.length > 0 && currentProject.id) {
                saveProject();
                console.log('Auto-saved project');
            }
        }, 5 * 60 * 1000);
        
        // PDF Modal Functions
        let currentModalPage = 1;
        let totalModalPages = 1;
        
        async function showPdfPageForDoc(docId, pageNum) {
            // Find the document
            const doc = currentProject.documents.find(d => d.id === docId);
            if (!doc) {
                alert('Document not found');
                return;
            }
            
            // Check for file data (new structure) or pdfData (old structure)
            const fileData = doc.fileData || doc.pdfData;
            if (!fileData) {
                alert('File data not available for this document');
                return;
            }
            
            // Determine file type (backward compatibility)
            const fileType = doc.type || 'pdf';
            
            // Check if it's a PDF
            if (fileType !== 'pdf') {
                // For non-PDF files, show location info instead
                showNonPDFLocation(doc, pageNum);
                return;
            }
            
            // Validate page number
            if (!pageNum || pageNum === 'Unknown' || isNaN(pageNum)) {
                alert('Page number not available for this context');
                return;
            }
            
            try {
                // Convert Blob to ArrayBuffer
                const arrayBuffer = await fileData.arrayBuffer();
                
                // Load PDF from ArrayBuffer
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                // Validate page is within range
                if (pageNum < 1 || pageNum > pdf.numPages) {
                    alert(`Invalid page number: ${pageNum}. Document has ${pdf.numPages} pages.`);
                    return;
                }
                
                currentModalPage = pageNum;
                totalModalPages = pdf.numPages;
                
                // Store for modal navigation
                window.currentModalPDF = pdf;
                window.currentModalDoc = doc;
                
                const modal = document.getElementById('pdfModal');
                modal.classList.add('active');
                
                await renderPdfPageFromPDF(pdf, pageNum);
                updateModalControls();
            } catch (error) {
                console.error('Error loading PDF:', error);
                alert('Failed to load PDF: ' + error.message);
            }
        }
        
        function showNonPDFLocation(doc, location) {
            const fileType = doc.type.toUpperCase();
            let locationText = '';
            
            if (typeof location === 'object') {
                if (location.sheet) {
                    locationText = `Sheet: ${location.sheet}, Row: ${location.row}, Column: ${location.col}`;
                } else if (location.line) {
                    locationText = `Line: ${location.line}`;
                } else if (location.section) {
                    locationText = `Section/Paragraph: ${location.section}`;
                }
            } else {
                locationText = `Location: ${location}`;
            }
            
            alert(`${fileType} Document: ${doc.name}\n${locationText}\n\nNote: Visual preview only available for PDF files. Click "Open Full ${fileType}" to view the complete file.`);
        }
        
        async function renderPdfPageFromPDF(pdf, pageNum) {
            const page = await pdf.getPage(pageNum);
            
            const canvas = document.getElementById('pdfPageCanvas');
            const ctx = canvas.getContext('2d');
            
            const viewport = page.getViewport({ scale: 1.5 });
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            const renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            
            await page.render(renderContext).promise;
            
            const docName = window.currentModalDoc ? window.currentModalDoc.name : '';
            document.getElementById('pdfModalTitle').textContent = `${docName} - Page ${pageNum} of ${totalModalPages}`;
        }
        
        async function showPdfPage(pageNum) {
            if (!window.currentPDF) {
                alert('PDF not loaded');
                return;
            }
            
            currentModalPage = pageNum;
            totalModalPages = window.currentPDF.numPages;
            
            const modal = document.getElementById('pdfModal');
            modal.classList.add('active');
            
            await renderPdfPage(pageNum);
            updateModalControls();
        }
        
        async function renderPdfPage(pageNum) {
            const pdf = window.currentPDF;
            const page = await pdf.getPage(pageNum);
            
            const canvas = document.getElementById('pdfPageCanvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate scale to fit modal nicely
            const viewport = page.getViewport({ scale: 1.5 });
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            const renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            
            await page.render(renderContext).promise;
            
            document.getElementById('pdfModalTitle').textContent = `Page ${pageNum} of ${totalModalPages}`;
        }
        
        function updateModalControls() {
            document.getElementById('prevPageBtn').disabled = currentModalPage <= 1;
            document.getElementById('nextPageBtn').disabled = currentModalPage >= totalModalPages;
        }
        
        async function navigatePage(direction) {
            const newPage = currentModalPage + direction;
            if (newPage >= 1 && newPage <= totalModalPages) {
                currentModalPage = newPage;
                if (window.currentModalPDF) {
                    await renderPdfPageFromPDF(window.currentModalPDF, currentModalPage);
                } else {
                    await renderPdfPage(currentModalPage);
                }
                updateModalControls();
            }
        }
        
        function closePdfModal() {
            document.getElementById('pdfModal').classList.remove('active');
        }
        
        function openFullPdf() {
            let pdfData = null;
            
            // Try to get from current modal doc
            if (window.currentModalDoc && window.currentModalDoc.pdfData) {
                pdfData = window.currentModalDoc.pdfData;
            } else if (window.currentPDFFile) {
                // Fallback to legacy single-file mode
                pdfData = window.currentPDFFile;
            }
            
            if (!pdfData) {
                alert('PDF file not available');
                return;
            }
            
            // Create blob URL and open in new tab
            const blob = new Blob([pdfData], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
        }
        
        // Close modal on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closePdfModal();
            }
        });
        
        // Close modal on background click
        document.getElementById('pdfModal').addEventListener('click', (e) => {
            if (e.target.id === 'pdfModal') {
                closePdfModal();
            }
        });
        
        // ===== RESEARCH ASSISTANT FUNCTIONS =====
        
        function toggleAssistant() {
            const panel = document.getElementById('assistantPanel');
            panel.classList.toggle('active');
            
            // Update status
            if (panel.classList.contains('active')) {
                updateAssistantStatus();
            }
        }
        
        function updateAssistantStatus() {
            const statusEl = document.getElementById('projectContext');
            if (currentProject.documents.length > 0) {
                const totalEntities = currentProject.aggregatedEntities.people.length +
                                    currentProject.aggregatedEntities.organizations.length +
                                    currentProject.aggregatedEntities.places.length +
                                    currentProject.aggregatedEntities.events.length;
                statusEl.textContent = `${currentProject.name} ‚Ä¢ ${currentProject.documents.length} docs ‚Ä¢ ${totalEntities} entities`;
            } else {
                statusEl.textContent = 'No project loaded';
            }
        }
        
        // Enter key to send
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('assistantInput');
            if (input) {
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendAssistantQuery();
                    }
                });
            }
        });
        
        async function sendAssistantQuery() {
            const input = document.getElementById('assistantInput');
            const query = input.value.trim();
            
            if (!query) return;
            
            if (currentProject.documents.length === 0) {
                addAssistantMessage('assistant', 'Please load or create a project with documents first.');
                return;
            }
            
            // Add user message
            addAssistantMessage('user', query);
            input.value = '';
            
            // Show thinking indicator
            const thinkingId = addThinkingIndicator();
            
            // Disable send button
            const sendBtn = document.getElementById('assistantSendBtn');
            sendBtn.disabled = true;
            
            try {
                // Process query
                const result = await processQuery(query);
                
                // Remove thinking indicator
                removeThinkingIndicator(thinkingId);
                
                // Add result message
                addAssistantMessage('assistant', result);
            } catch (error) {
                removeThinkingIndicator(thinkingId);
                addAssistantMessage('assistant', `Error processing query: ${error.message}`);
            }
            
            sendBtn.disabled = false;
        }
        
        function addAssistantMessage(type, content) {
            const chat = document.getElementById('assistantChat');
            const messageDiv = document.createElement('div');
            messageDiv.className = `assistant-message message-${type}`;
            
            const label = document.createElement('div');
            label.className = 'message-label';
            label.textContent = type === 'user' ? 'YOU' : 'ASSISTANT';
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            
            if (typeof content === 'string') {
                bubble.innerHTML = content;
            } else {
                bubble.appendChild(content);
            }
            
            messageDiv.appendChild(label);
            messageDiv.appendChild(bubble);
            chat.appendChild(messageDiv);
            
            // Scroll to bottom
            chat.scrollTop = chat.scrollHeight;
        }
        
        function addThinkingIndicator() {
            const chat = document.getElementById('assistantChat');
            const thinkingDiv = document.createElement('div');
            const thinkingId = 'thinking_' + Date.now();
            thinkingDiv.id = thinkingId;
            thinkingDiv.className = 'assistant-message message-assistant';
            thinkingDiv.innerHTML = `
                <div class="message-label">ASSISTANT</div>
                <div class="message-bubble thinking-indicator">
                    <span>Analyzing your data</span><span class="thinking-dots"></span>
                </div>
            `;
            chat.appendChild(thinkingDiv);
            chat.scrollTop = chat.scrollHeight;
            return thinkingId;
        }
        
        function removeThinkingIndicator(thinkingId) {
            const el = document.getElementById(thinkingId);
            if (el) el.remove();
        }
        
        async function processQuery(query) {
            const lowerQuery = query.toLowerCase();
            
            // Parse query type
            if (lowerQuery.includes('show') || lowerQuery.includes('list') || lowerQuery.includes('find')) {
                return handleListQuery(query, lowerQuery);
            } else if (lowerQuery.includes('how many') || lowerQuery.includes('count')) {
                return handleCountQuery(query, lowerQuery);
            } else if (lowerQuery.includes('compare') || lowerQuery.includes('difference')) {
                return handleCompareQuery(query, lowerQuery);
            } else if (lowerQuery.includes('where') || lowerQuery.includes('which document')) {
                return handleWhereQuery(query, lowerQuery);
            } else if (lowerQuery.includes('together') || lowerQuery.includes('both') || lowerQuery.includes('and')) {
                return handleCoOccurrenceQuery(query, lowerQuery);
            } else if (lowerQuery.includes('timeline') || lowerQuery.includes('chronological') || lowerQuery.includes('order')) {
                return handleTimelineQuery(query, lowerQuery);
            } else {
                return handleGeneralQuery(query, lowerQuery);
            }
        }
        
        function handleListQuery(query, lowerQuery) {
            let results = [];
            let title = '';
            
            // Detect entity type
            if (lowerQuery.includes('people') || lowerQuery.includes('person')) {
                results = currentProject.aggregatedEntities.people;
                title = 'People';
            } else if (lowerQuery.includes('organization') || lowerQuery.includes('company') || lowerQuery.includes('companies')) {
                results = currentProject.aggregatedEntities.organizations;
                title = 'Organizations';
            } else if (lowerQuery.includes('location') || lowerQuery.includes('place') || lowerQuery.includes('city') || lowerQuery.includes('cities')) {
                results = currentProject.aggregatedEntities.places;
                title = 'Locations';
            } else if (lowerQuery.includes('event')) {
                results = currentProject.aggregatedEntities.events;
                title = 'Events';
            } else {
                // Show all
                title = 'All Entities';
                results = [
                    ...currentProject.aggregatedEntities.people,
                    ...currentProject.aggregatedEntities.organizations,
                    ...currentProject.aggregatedEntities.places,
                    ...currentProject.aggregatedEntities.events
                ];
            }
            
            // Apply filters
            const mentionMatch = lowerQuery.match(/(?:more than|at least|over|>\s*)(\d+)/);
            if (mentionMatch) {
                const threshold = parseInt(mentionMatch[1]);
                results = results.filter(e => e.totalCount > threshold);
                title += ` (>${threshold} mentions)`;
            }
            
            const docMatch = lowerQuery.match(/(?:in|across)\s+(\d+)\s+document/);
            if (docMatch) {
                const docThreshold = parseInt(docMatch[1]);
                results = results.filter(e => e.documents && e.documents.length >= docThreshold);
                title += ` (in ${docThreshold}+ docs)`;
            }
            
            // Sort by mention count
            results.sort((a, b) => b.totalCount - a.totalCount);
            
            // Limit results
            const limit = 50;
            const limited = results.slice(0, limit);
            
            return formatEntityList(title, limited, results.length > limit ? results.length - limit : 0);
        }
        
        function formatEntityList(title, entities, moreCount) {
            let html = `<div class="result-count"><strong>${title}</strong> ‚Ä¢ Found ${entities.length} ${moreCount > 0 ? `(+${moreCount} more)` : ''}</div>`;
            html += '<div class="query-result">';
            
            entities.forEach(entity => {
                const docList = entity.documents ? entity.documents.map(d => d.docName).join(', ') : '';
                html += `<div class="result-item" onclick="showEntityFromAssistant('${escapeHtml(entity.name)}')">`;
                html += `<strong>${escapeHtml(entity.name)}</strong> ‚Ä¢ ${entity.totalCount}√ó mentions`;
                if (entity.documents) {
                    html += ` ‚Ä¢ ${entity.documents.length} docs`;
                }
                html += `</div>`;
            });
            
            html += '</div>';
            
            // Add export button for list results
            html += `<div style="margin-top: 15px;">`;
            html += `<button class="project-btn" onclick="exportListResults('${escapeHtml(title)}')">üì• Export Results</button>`;
            html += `</div>`;
            
            // Store results for export
            window.lastListResults = { title, entities };
            
            return html;
        }
        
        function exportListResults(title) {
            const data = window.lastListResults || { title: 'Results', entities: [] };
            
            const exportHtml = `
                <div style="margin-top: 15px; padding: 15px; background: rgba(0, 255, 65, 0.05); border: 1px solid var(--border-color); border-radius: 4px;">
                    <div style="margin-bottom: 10px;"><strong>Export Options:</strong></div>
                    <button class="project-btn" onclick="exportEntityListAsJSON()" style="margin-right: 10px;">üìÑ JSON</button>
                    <button class="project-btn" onclick="exportEntityListAsCSV()" style="margin-right: 10px;">üìä CSV</button>
                    <button class="project-btn" onclick="exportEntityListAsHTML()">üåê HTML Report</button>
                </div>
            `;
            
            addAssistantMessage('assistant', exportHtml);
        }
        
        function exportEntityListAsJSON() {
            const data = window.lastListResults || { entities: [] };
            const exportData = {
                project: currentProject.name,
                timestamp: new Date().toISOString(),
                queryTitle: data.title,
                entityCount: data.entities.length,
                entities: data.entities
            };
            const json = JSON.stringify(exportData, null, 2);
            downloadFile(json, `entity_list_${Date.now()}.json`, 'application/json');
            addAssistantMessage('assistant', '‚úÖ Exported as JSON! Check your downloads.');
        }
        
        function exportEntityListAsCSV() {
            const data = window.lastListResults || { entities: [] };
            let csv = 'Entity Name,Total Mentions,Document Count,Documents\n';
            
            data.entities.forEach(e => {
                const docs = e.documents ? e.documents.map(d => d.docName).join('; ') : '';
                const docCount = e.documents ? e.documents.length : 1;
                csv += `"${e.name}",${e.totalCount},${docCount},"${docs}"\n`;
            });
            
            downloadFile(csv, `entity_list_${Date.now()}.csv`, 'text/csv');
            addAssistantMessage('assistant', '‚úÖ Exported as CSV! Check your downloads.');
        }
        
        function exportEntityListAsHTML() {
            const data = window.lastListResults || { entities: [] };
            const html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${data.title} - ${currentProject.name}</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 40px; background: #f5f5f5; }
        .header { background: #2c3e50; color: white; padding: 30px; border-radius: 8px; margin-bottom: 30px; }
        .header h1 { margin: 0 0 10px 0; }
        .section { background: white; padding: 25px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .section h2 { margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .entity-item { padding: 15px; margin: 10px 0; background: #ecf0f1; border-left: 4px solid #3498db; border-radius: 4px; }
        .entity-name { font-size: 1.1em; font-weight: bold; color: #2c3e50; }
        .entity-meta { color: #7f8c8d; font-size: 0.9em; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${escapeHtml(data.title)}</h1>
        <div>Project: ${escapeHtml(currentProject.name)}</div>
        <div>Generated: ${new Date().toLocaleString()}</div>
    </div>
    
    <div class="section">
        <h2>Entities Found: ${data.entities.length}</h2>
        ${data.entities.map(e => `
            <div class="entity-item">
                <div class="entity-name">${escapeHtml(e.name)}</div>
                <div class="entity-meta">
                    ${e.totalCount} total mentions
                    ${e.documents ? ` ‚Ä¢ ${e.documents.length} documents: ${e.documents.map(d => escapeHtml(d.docName)).join(', ')}` : ''}
                </div>
            </div>
        `).join('')}
    </div>
</body>
</html>`;
            
            downloadFile(html, `entity_list_${Date.now()}.html`, 'text/html');
            addAssistantMessage('assistant', '‚úÖ Exported as HTML Report! Check your downloads.');
        }
        
        function showEntityFromAssistant(entityName) {
            // Find entity type
            let entityType = null;
            if (currentProject.aggregatedEntities.people.find(e => e.name === entityName)) {
                entityType = 'person';
            } else if (currentProject.aggregatedEntities.organizations.find(e => e.name === entityName)) {
                entityType = 'organization';
            } else if (currentProject.aggregatedEntities.places.find(e => e.name === entityName)) {
                entityType = 'location';
            } else if (currentProject.aggregatedEntities.events.find(e => e.name === entityName)) {
                entityType = 'event';
            }
            
            if (entityType) {
                // Close assistant panel
                toggleAssistant();
                // Show entity context in main view
                showAggregatedEntityContext(entityName, entityType);
            }
        }
        
        function handleCountQuery(query, lowerQuery) {
            const people = currentProject.aggregatedEntities.people.length;
            const orgs = currentProject.aggregatedEntities.organizations.length;
            const places = currentProject.aggregatedEntities.places.length;
            const events = currentProject.aggregatedEntities.events.length;
            const docs = currentProject.documents.length;
            
            let html = '<div class="query-result">';
            html += `<div style="font-size: 1.1em; margin-bottom: 15px;"><strong>Project Statistics</strong></div>`;
            html += `<div>üìÑ <strong>Documents:</strong> ${docs}</div>`;
            html += `<div>üë§ <strong>People:</strong> ${people}</div>`;
            html += `<div>üè¢ <strong>Organizations:</strong> ${orgs}</div>`;
            html += `<div>üìç <strong>Locations:</strong> ${places}</div>`;
            html += `<div>üìÖ <strong>Events:</strong> ${events}</div>`;
            html += `<div style="margin-top: 10px;"><strong>Total Entities:</strong> ${people + orgs + places + events}</div>`;
            html += '</div>';
            
            return html;
        }
        
        function handleCompareQuery(query, lowerQuery) {
            // Extract document numbers or names
            return 'Document comparison feature coming soon! For now, try filtering entities by document count.';
        }
        
        function handleWhereQuery(query, lowerQuery) {
            // Search for entity mentions
            return 'Entity location search coming soon! For now, click any entity to see all its contexts.';
        }
        
        function handleCoOccurrenceQuery(query, lowerQuery) {
            // Extract entity names from query
            const entities = extractEntityNamesFromQuery(query);
            
            if (entities.length < 2) {
                return 'Please specify at least two entities to find co-occurrences. Example: "Show where Jeffrey Epstein and Ghislaine Maxwell appear together"';
            }
            
            // Find contexts where all specified entities appear
            const coOccurrences = findCoOccurrences(entities);
            
            if (coOccurrences.length === 0) {
                return `No contexts found where ${entities.map(e => `"${e}"`).join(' and ')} appear together.`;
            }
            
            let html = `<div class="result-count"><strong>Co-occurrence Analysis</strong> ‚Ä¢ Found ${coOccurrences.length} contexts</div>`;
            html += `<div style="margin-bottom: 10px; color: var(--text-secondary);">Entities: ${entities.map(e => escapeHtml(e)).join(' + ')}</div>`;
            html += '<div class="query-result">';
            
            coOccurrences.slice(0, 20).forEach((context, idx) => {
                html += `<div class="result-item">`;
                html += `<strong>${idx + 1}. ${escapeHtml(context.docName)}</strong><br>`;
                html += `<span style="font-size: 0.9em; color: var(--text-secondary);">${context.locationDisplay}</span><br>`;
                html += `<div style="font-size: 0.85em; margin-top: 5px;">${context.text}</div>`;
                html += `</div>`;
            });
            
            if (coOccurrences.length > 20) {
                html += `<div style="padding: 10px; text-align: center; color: var(--text-secondary);">+${coOccurrences.length - 20} more contexts</div>`;
            }
            
            html += '</div>';
            html += `<div style="margin-top: 15px;"><button class="project-btn" onclick="exportQueryResults('co-occurrence', '${entities.join(',')}')">üì• Export Results</button></div>`;
            return html;
        }
        
        function extractEntityNamesFromQuery(query) {
            const entities = [];
            
            // Get all known entities
            const allEntities = [
                ...currentProject.aggregatedEntities.people.map(e => e.name),
                ...currentProject.aggregatedEntities.organizations.map(e => e.name),
                ...currentProject.aggregatedEntities.places.map(e => e.name),
                ...currentProject.aggregatedEntities.events.map(e => e.name)
            ];
            
            // Find entities mentioned in query (case insensitive)
            allEntities.forEach(entity => {
                if (query.toLowerCase().includes(entity.toLowerCase())) {
                    entities.push(entity);
                }
            });
            
            return entities;
        }
        
        function findCoOccurrences(entityNames) {
            const results = [];
            
            // Search through all documents
            currentProject.documents.forEach(doc => {
                const analysis = doc.analysis;
                
                analysis.sentences.forEach((sentence, index) => {
                    // Check if ALL entities appear in this sentence
                    const allPresent = entityNames.every(entityName => {
                        const pattern = createVariationPattern(entityName);
                        return pattern.test(sentence);
                    });
                    
                    if (allPresent) {
                        // Get location info
                        let locationDisplay = 'Unknown';
                        const fileType = doc.type || 'pdf';
                        
                        if (analysis.locationMap && analysis.locationMap[index]) {
                            const loc = analysis.locationMap[index];
                            switch(fileType) {
                                case 'pdf': locationDisplay = `Page ${loc.page || loc}`; break;
                                case 'docx': locationDisplay = `Section ${loc.section || loc}`; break;
                                case 'xlsx': locationDisplay = `${loc.sheet}, Row ${loc.row}`; break;
                                case 'txt': case 'md': locationDisplay = `Line ${loc.line || loc}`; break;
                            }
                        } else if (analysis.sentenceToPage && analysis.sentenceToPage[index]) {
                            locationDisplay = `Page ${analysis.sentenceToPage[index].page}`;
                        }
                        
                        // Highlight all entities
                        let highlighted = sentence;
                        entityNames.forEach(entityName => {
                            const pattern = createVariationPattern(entityName);
                            highlighted = highlighted.replace(pattern, (match) => {
                                return `<span class="context-highlight">${match}</span>`;
                            });
                        });
                        
                        results.push({
                            docId: doc.id,
                            docName: doc.name,
                            index: index,
                            locationDisplay: locationDisplay,
                            text: highlighted,
                            textPreview: sentence.substring(0, 150)
                        });
                    }
                });
            });
            
            return results;
        }
        
        function handleCompareQuery(query, lowerQuery) {
            // Extract document references
            const docMatches = query.match(/doc(?:ument)?\s*(\d+)/gi);
            if (!docMatches || docMatches.length < 2) {
                return 'Please specify at least two documents to compare. Example: "Compare entities in document 1 and document 3"';
            }
            
            const docIndices = docMatches.map(m => parseInt(m.match(/\d+/)[0]) - 1);
            const docs = docIndices.map(i => currentProject.documents[i]).filter(d => d);
            
            if (docs.length < 2) {
                return 'Could not find the specified documents. Make sure document numbers are valid.';
            }
            
            // Compare entities
            const comparison = compareDocuments(docs);
            
            let html = `<div class="result-count"><strong>Document Comparison</strong></div>`;
            html += '<div class="query-result">';
            
            html += `<div style="margin-bottom: 15px;">`;
            html += `<strong>Document 1:</strong> ${escapeHtml(docs[0].name)}<br>`;
            html += `<strong>Document 2:</strong> ${escapeHtml(docs[1].name)}`;
            html += `</div>`;
            
            html += `<div style="margin-bottom: 10px;"><strong>Shared Entities (${comparison.shared.length}):</strong></div>`;
            comparison.shared.slice(0, 15).forEach(entity => {
                html += `<div class="result-item" onclick="showEntityFromAssistant('${escapeHtml(entity)}')">${escapeHtml(entity)}</div>`;
            });
            
            html += `<div style="margin: 15px 0 10px 0;"><strong>Only in ${escapeHtml(docs[0].name)} (${comparison.onlyFirst.length}):</strong></div>`;
            comparison.onlyFirst.slice(0, 10).forEach(entity => {
                html += `<div class="result-item" onclick="showEntityFromAssistant('${escapeHtml(entity)}')">${escapeHtml(entity)}</div>`;
            });
            
            html += `<div style="margin: 15px 0 10px 0;"><strong>Only in ${escapeHtml(docs[1].name)} (${comparison.onlySecond.length}):</strong></div>`;
            comparison.onlySecond.slice(0, 10).forEach(entity => {
                html += `<div class="result-item" onclick="showEntityFromAssistant('${escapeHtml(entity)}')">${escapeHtml(entity)}</div>`;
            });
            
            html += '</div>';
            return html;
        }
        
        function compareDocuments(docs) {
            const getEntities = (doc) => {
                const analysis = doc.analysis;
                return [
                    ...analysis.entities.people.map(e => e.name),
                    ...analysis.entities.organizations.map(e => e.name),
                    ...analysis.entities.places.map(e => e.name),
                    ...analysis.entities.events.map(e => e.name)
                ];
            };
            
            const entities1 = new Set(getEntities(docs[0]));
            const entities2 = new Set(getEntities(docs[1]));
            
            const shared = [...entities1].filter(e => entities2.has(e));
            const onlyFirst = [...entities1].filter(e => !entities2.has(e));
            const onlySecond = [...entities2].filter(e => !entities1.has(e));
            
            return { shared, onlyFirst, onlySecond };
        }
        
        function handleWhereQuery(query, lowerQuery) {
            // Extract entity name from query
            const entities = extractEntityNamesFromQuery(query);
            
            if (entities.length === 0) {
                return 'Please specify an entity to search for. Example: "Which documents mention Jeffrey Epstein?"';
            }
            
            const entityName = entities[0];
            
            // Find entity in aggregated data
            let entityData = null;
            let entityType = null;
            
            if (currentProject.aggregatedEntities.people.find(e => e.name === entityName)) {
                entityData = currentProject.aggregatedEntities.people.find(e => e.name === entityName);
                entityType = 'person';
            } else if (currentProject.aggregatedEntities.organizations.find(e => e.name === entityName)) {
                entityData = currentProject.aggregatedEntities.organizations.find(e => e.name === entityName);
                entityType = 'organization';
            } else if (currentProject.aggregatedEntities.places.find(e => e.name === entityName)) {
                entityData = currentProject.aggregatedEntities.places.find(e => e.name === entityName);
                entityType = 'location';
            } else if (currentProject.aggregatedEntities.events.find(e => e.name === entityName)) {
                entityData = currentProject.aggregatedEntities.events.find(e => e.name === entityName);
                entityType = 'event';
            }
            
            if (!entityData) {
                return `Entity "${entityName}" not found in the project data.`;
            }
            
            let html = `<div class="result-count"><strong>${escapeHtml(entityName)}</strong> ‚Ä¢ ${entityData.totalCount} total mentions</div>`;
            html += '<div class="query-result">';
            html += `<div style="margin-bottom: 15px;"><strong>Appears in ${entityData.documents.length} document(s):</strong></div>`;
            
            entityData.documents.forEach(doc => {
                html += `<div class="result-item">`;
                html += `<strong>${escapeHtml(doc.docName)}</strong><br>`;
                html += `<span style="color: var(--text-secondary);">${doc.count} mentions</span>`;
                html += `</div>`;
            });
            
            html += '</div>';
            html += `<div style="margin-top: 15px;"><button class="project-btn" onclick="showEntityFromAssistant('${escapeHtml(entityName)}')">View All Contexts</button></div>`;
            return html;
        }
        
        function handleTimelineQuery(query, lowerQuery) {
            // Extract date patterns and events from all documents
            const timelineData = extractTimelineData();
            
            if (timelineData.length === 0) {
                return 'No dated events found in the documents. Timeline generation requires explicit dates or timestamps in the text.';
            }
            
            // Sort chronologically
            timelineData.sort((a, b) => {
                if (a.timestamp && b.timestamp) {
                    return new Date(a.timestamp) - new Date(b.timestamp);
                }
                return 0;
            });
            
            let html = `<div class="result-count"><strong>Timeline Analysis</strong> ‚Ä¢ Found ${timelineData.length} dated events</div>`;
            html += '<div class="query-result">';
            
            timelineData.slice(0, 30).forEach((event, idx) => {
                html += `<div class="result-item">`;
                html += `<strong>${event.dateDisplay}</strong><br>`;
                html += `<span style="font-size: 0.9em; color: var(--text-secondary);">${escapeHtml(event.docName)} | ${event.locationDisplay}</span><br>`;
                html += `<div style="font-size: 0.85em; margin-top: 5px;">${event.context}</div>`;
                html += `</div>`;
            });
            
            if (timelineData.length > 30) {
                html += `<div style="padding: 10px; text-align: center; color: var(--text-secondary);">+${timelineData.length - 30} more events</div>`;
            }
            
            html += '</div>';
            html += `<div style="margin-top: 15px;">`;
            html += `<button class="project-btn" onclick="exportTimelineVisualization()" style="margin-right: 10px;">üìà Export Timeline Chart</button>`;
            html += `<button class="project-btn" onclick="exportTimelineAsJSON()">üìÑ Export as JSON</button>`;
            html += `</div>`;
            
            // Store for export
            window.lastTimelineData = timelineData;
            
            return html;
        }
        
        function extractTimelineData() {
            const events = [];
            const datePattern = /\b(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+\d{1,2},?\s+\d{4}\b/gi;
            const datePattern2 = /\b\d{1,2}[-/]\d{1,2}[-/]\d{2,4}\b/g;
            
            currentProject.documents.forEach(doc => {
                const analysis = doc.analysis;
                
                analysis.sentences.forEach((sentence, index) => {
                    // Check for date patterns
                    const matches1 = sentence.match(datePattern);
                    const matches2 = sentence.match(datePattern2);
                    const allMatches = [...(matches1 || []), ...(matches2 || [])];
                    
                    if (allMatches.length > 0) {
                        allMatches.forEach(dateStr => {
                            // Get location info
                            let locationDisplay = 'Unknown';
                            const fileType = doc.type || 'pdf';
                            
                            if (analysis.locationMap && analysis.locationMap[index]) {
                                const loc = analysis.locationMap[index];
                                switch(fileType) {
                                    case 'pdf': locationDisplay = `Page ${loc.page || loc}`; break;
                                    case 'docx': locationDisplay = `Section ${loc.section || loc}`; break;
                                    case 'xlsx': locationDisplay = `${loc.sheet}, Row ${loc.row}`; break;
                                    case 'txt': case 'md': locationDisplay = `Line ${loc.line || loc}`; break;
                                }
                            } else if (analysis.sentenceToPage && analysis.sentenceToPage[index]) {
                                locationDisplay = `Page ${analysis.sentenceToPage[index].page}`;
                            }
                            
                            events.push({
                                dateDisplay: dateStr,
                                timestamp: parseDate(dateStr),
                                docName: doc.name,
                                docId: doc.id,
                                locationDisplay: locationDisplay,
                                context: sentence.substring(0, 200)
                            });
                        });
                    }
                });
            });
            
            return events;
        }
        
        function parseDate(dateStr) {
            try {
                return new Date(dateStr).toISOString();
            } catch (e) {
                return null;
            }
        }
        
        function exportTimelineVisualization() {
            const data = window.lastTimelineData || [];
            const html = generateTimelineHTML(data);
            downloadFile(html, `timeline_${Date.now()}.html`, 'text/html');
            addAssistantMessage('assistant', '‚úÖ Timeline chart exported! Check your downloads and open in browser.');
        }
        
        function exportTimelineAsJSON() {
            const data = window.lastTimelineData || [];
            const json = JSON.stringify({
                project: currentProject.name,
                generated: new Date().toISOString(),
                eventCount: data.length,
                events: data
            }, null, 2);
            downloadFile(json, `timeline_${Date.now()}.json`, 'application/json');
            addAssistantMessage('assistant', '‚úÖ Timeline exported as JSON! Check your downloads.');
        }
        
        function generateTimelineHTML(events) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Timeline - ${currentProject.name}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a1a; color: #e0e0e0; padding: 40px; }
        .header { text-align: center; margin-bottom: 50px; }
        .header h1 { color: #00ff41; font-size: 2.5em; margin-bottom: 10px; }
        .header .meta { color: #888; }
        .timeline { position: relative; max-width: 1200px; margin: 0 auto; }
        .timeline::before { content: ''; position: absolute; left: 50%; top: 0; bottom: 0; width: 4px; background: #00ff41; transform: translateX(-50%); }
        .event { position: relative; margin: 40px 0; }
        .event.left { text-align: right; padding-right: calc(50% + 40px); }
        .event.right { text-align: left; padding-left: calc(50% + 40px); }
        .event-marker { position: absolute; left: 50%; top: 20px; width: 20px; height: 20px; background: #00ff41; border: 4px solid #1a1a1a; border-radius: 50%; transform: translate(-50%, -50%); z-index: 2; box-shadow: 0 0 20px #00ff41; }
        .event-content { background: #2a2a2a; padding: 20px; border-radius: 8px; border: 1px solid #333; }
        .event-date { color: #00ff41; font-weight: bold; font-size: 1.1em; margin-bottom: 10px; }
        .event-doc { color: #888; font-size: 0.85em; margin-bottom: 8px; }
        .event-context { line-height: 1.6; color: #ccc; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Timeline Analysis</h1>
        <div class="meta">${currentProject.name} ‚Ä¢ ${events.length} Events</div>
        <div class="meta">Generated: ${new Date().toLocaleString()}</div>
    </div>
    
    <div class="timeline">
        ${events.map((event, idx) => `
            <div class="event ${idx % 2 === 0 ? 'left' : 'right'}">
                <div class="event-marker"></div>
                <div class="event-content">
                    <div class="event-date">${escapeHtml(event.dateDisplay)}</div>
                    <div class="event-doc">${escapeHtml(event.docName)} | ${event.locationDisplay}</div>
                    <div class="event-context">${escapeHtml(event.context)}</div>
                </div>
            </div>
        `).join('')}
    </div>
</body>
</html>`;
        }
        
        function exportQueryResults(queryType, params) {
            // Store current query results for export
            window.lastQueryResults = {
                type: queryType,
                params: params,
                timestamp: new Date().toISOString()
            };
            
            // Show export options
            const exportHtml = `
                <div style="margin-top: 15px; padding: 15px; background: rgba(0, 255, 65, 0.05); border: 1px solid var(--border-color); border-radius: 4px;">
                    <div style="margin-bottom: 10px;"><strong>Export Options:</strong></div>
                    <button class="project-btn" onclick="exportAsJSON()" style="margin-right: 10px;">üìÑ JSON</button>
                    <button class="project-btn" onclick="exportAsCSV()" style="margin-right: 10px;">üìä CSV</button>
                    <button class="project-btn" onclick="exportAsHTML()">üåê HTML Report</button>
                </div>
            `;
            
            addAssistantMessage('assistant', exportHtml);
        }
        
        function exportAsJSON() {
            const data = buildExportData();
            const json = JSON.stringify(data, null, 2);
            downloadFile(json, `research_query_${Date.now()}.json`, 'application/json');
            addAssistantMessage('assistant', '‚úÖ Exported as JSON! Check your downloads.');
        }
        
        function exportAsCSV() {
            const data = buildExportData();
            let csv = '';
            
            // Add header based on query type
            if (data.contexts && data.contexts.length > 0) {
                csv = 'Document,Location,Entity,Context\n';
                data.contexts.forEach(ctx => {
                    const cleanText = ctx.text.replace(/<[^>]*>/g, '').replace(/"/g, '""');
                    csv += `"${ctx.docName}","${ctx.locationDisplay}","${data.entities.join(' + ')}","${cleanText}"\n`;
                });
            } else if (data.entities && data.entities.length > 0) {
                csv = 'Entity,Type,Total Mentions,Document Count\n';
                data.entities.forEach(e => {
                    csv += `"${e.name}","${e.type}",${e.totalCount},${e.documents ? e.documents.length : 1}\n`;
                });
            }
            
            downloadFile(csv, `research_query_${Date.now()}.csv`, 'text/csv');
            addAssistantMessage('assistant', '‚úÖ Exported as CSV! Check your downloads.');
        }
        
        function exportAsHTML() {
            const data = buildExportData();
            const html = generateHTMLReport(data);
            downloadFile(html, `research_report_${Date.now()}.html`, 'text/html');
            addAssistantMessage('assistant', '‚úÖ Exported as HTML Report! Check your downloads.');
        }
        
        function buildExportData() {
            const queryResults = window.lastQueryResults || {};
            const data = {
                project: currentProject.name,
                timestamp: new Date().toISOString(),
                queryType: queryResults.type,
                params: queryResults.params,
                entities: [],
                contexts: []
            };
            
            // Build data based on query type
            if (queryResults.type === 'co-occurrence') {
                const entityNames = queryResults.params.split(',');
                data.entities = entityNames;
                data.contexts = findCoOccurrences(entityNames);
            }
            
            return data;
        }
        
        function generateHTMLReport(data) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Research Report - ${data.project}</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 40px; background: #f5f5f5; }
        .header { background: #2c3e50; color: white; padding: 30px; border-radius: 8px; margin-bottom: 30px; }
        .header h1 { margin: 0 0 10px 0; }
        .header .meta { opacity: 0.8; font-size: 0.9em; }
        .section { background: white; padding: 25px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .section h2 { margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .context-item { padding: 15px; margin: 10px 0; background: #ecf0f1; border-left: 4px solid #3498db; border-radius: 4px; }
        .context-meta { font-size: 0.85em; color: #7f8c8d; margin-bottom: 8px; }
        .highlight { background: #f39c12; padding: 2px 4px; border-radius: 2px; }
        .entity-badge { display: inline-block; background: #3498db; color: white; padding: 4px 12px; border-radius: 12px; margin: 5px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Research Report: ${escapeHtml(data.project)}</h1>
        <div class="meta">Generated: ${new Date(data.timestamp).toLocaleString()}</div>
        <div class="meta">Query Type: ${data.queryType || 'Analysis'}</div>
    </div>
    
    ${data.entities.length > 0 ? `
    <div class="section">
        <h2>Entities Analyzed</h2>
        ${data.entities.map(e => `<span class="entity-badge">${typeof e === 'string' ? escapeHtml(e) : escapeHtml(e.name)}</span>`).join('')}
    </div>
    ` : ''}
    
    ${data.contexts.length > 0 ? `
    <div class="section">
        <h2>Context Analysis (${data.contexts.length} results)</h2>
        ${data.contexts.map((ctx, idx) => `
            <div class="context-item">
                <div class="context-meta"><strong>${idx + 1}. ${escapeHtml(ctx.docName)}</strong> | ${ctx.locationDisplay}</div>
                <div>${ctx.text}</div>
            </div>
        `).join('')}
    </div>
    ` : ''}
    
    <div class="section">
        <p style="text-align: center; color: #7f8c8d;">Generated by Master Research Hub</p>
    </div>
</body>
</html>`;
        }
        
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function handleGeneralQuery(query, lowerQuery) {
            return `I understand you're asking: "${query}"<br><br>
                <strong>Available Query Types:</strong><br><br>
                <strong>üìã Listing & Filtering:</strong><br>
                ‚Ä¢ "Show me all [people/organizations/locations/events]"<br>
                ‚Ä¢ "Show me entities mentioned more than X times"<br>
                ‚Ä¢ "List people in multiple documents"<br><br>
                <strong>üîó Relationship Analysis:</strong><br>
                ‚Ä¢ "Show where [entity 1] and [entity 2] appear together"<br>
                ‚Ä¢ "Find contexts with [entity] and [location]"<br><br>
                <strong>‚öñÔ∏è Comparison:</strong><br>
                ‚Ä¢ "Compare entities in document X and document Y"<br>
                ‚Ä¢ "Compare doc 1 and doc 3"<br><br>
                <strong>üìç Location Search:</strong><br>
                ‚Ä¢ "Which documents mention [entity]?"<br>
                ‚Ä¢ "Where is [organization] mentioned?"<br><br>
                <strong>üìà Timeline:</strong><br>
                ‚Ä¢ "Create a timeline"<br>
                ‚Ä¢ "Show events in chronological order"<br><br>
                <strong>üìä Statistics:</strong><br>
                ‚Ä¢ "How many [entities] are there?"<br>
                ‚Ä¢ "Count all entities"`;
        }
        
        // ===== GLOSSARY FUNCTIONS - OPTION C =====
        
        function toggleGlossary() {
            const panel = document.getElementById('glossaryPanel');
            if (!panel) {
                console.error('Glossary panel not found!');
                return;
            }
            
            console.log('Toggling glossary, current classes:', panel.className);
            panel.classList.toggle('active');
            console.log('After toggle, classes:', panel.className);
            
            if (panel.classList.contains('active')) {
                updateGlossaryDisplay();
            }
        }
        
        function updateGlossaryDisplay() {
            const content = document.getElementById('glossaryContent');
            const terms = currentProject.glossary.terms;
            
            document.getElementById('glossaryStatus').textContent = `${terms.length} terms loaded`;
            
            if (terms.length === 0) {
                content.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px 20px;">
                        <div style="font-size: 3em; margin-bottom: 15px;">üìö</div>
                        <div>No terms in glossary yet.</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">Click "Load CDC Terms" to get started,<br>or add custom terms manually.</div>
                    </div>
                `;
                return;
            }
            
            // Group by category
            const grouped = {};
            terms.forEach(term => {
                const cat = term.category || 'Uncategorized';
                if (!grouped[cat]) grouped[cat] = [];
                grouped[cat].push(term);
            });
            
            let html = '';
            Object.keys(grouped).sort().forEach(category => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<div style="font-size: 1.1em; color: var(--matrix-green); margin-bottom: 15px; font-family: 'Orbitron', monospace; border-bottom: 1px solid var(--border-color); padding-bottom: 5px;">${category}</div>`;
                
                grouped[category].forEach(term => {
                    html += `<div class="result-item" style="margin-bottom: 15px;">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: start;">`;
                    html += `<strong style="color: var(--matrix-green);">${escapeHtml(term.term)}</strong>`;
                    html += `<span onclick="removeTerm('${escapeHtml(term.term)}')" style="cursor: pointer; color: #ff0000; padding: 2px 8px; font-size: 0.9em;">‚úï</span>`;
                    html += `</div>`;
                    html += `<div style="margin-top: 5px; color: var(--text-primary); line-height: 1.5;">${escapeHtml(term.definition)}</div>`;
                    if (term.source) {
                        html += `<div style="margin-top: 5px; font-size: 0.85em; color: var(--text-secondary);">Source: ${escapeHtml(term.source)}</div>`;
                    }
                    html += `</div>`;
                });
                
                html += `</div>`;
            });
            
            content.innerHTML = html;
        }
        
        function filterGlossary() {
            const search = document.getElementById('glossarySearch').value.toLowerCase();
            const content = document.getElementById('glossaryContent');
            const terms = currentProject.glossary.terms;
            
            if (!search) {
                updateGlossaryDisplay();
                return;
            }
            
            const filtered = terms.filter(t => 
                t.term.toLowerCase().includes(search) || 
                t.definition.toLowerCase().includes(search)
            );
            
            if (filtered.length === 0) {
                content.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px 20px;">
                        No terms match "${escapeHtml(search)}"
                    </div>
                `;
                return;
            }
            
            let html = '';
            filtered.forEach(term => {
                html += `<div class="result-item" style="margin-bottom: 15px;">`;
                html += `<div style="display: flex; justify-content: space-between; align-items: start;">`;
                html += `<strong style="color: var(--matrix-green);">${escapeHtml(term.term)}</strong>`;
                html += `<span style="font-size: 0.85em; color: var(--text-secondary);">${term.category}</span>`;
                html += `</div>`;
                html += `<div style="margin-top: 5px; color: var(--text-primary);">${escapeHtml(term.definition)}</div>`;
                html += `</div>`;
            });
            
            content.innerHTML = html;
        }
        
        function showAddTermDialog() {
            const dialog = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel-bg); border: 2px solid var(--matrix-green); padding: 30px; border-radius: 8px; z-index: 2000; box-shadow: 0 0 50px rgba(0, 255, 65, 0.3); min-width: 500px;">
                    <div style="font-size: 1.3em; margin-bottom: 20px; color: var(--matrix-green); font-family: 'Orbitron', monospace;">Add Glossary Term</div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Term:</label>
                        <input type="text" id="newTerm" placeholder="e.g., CDC" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Share Tech Mono', monospace;" />
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Definition:</label>
                        <textarea id="newDefinition" placeholder="Centers for Disease Control and Prevention" rows="3" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Share Tech Mono', monospace;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Category:</label>
                        <select id="newCategory" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Share Tech Mono', monospace;">
                            <option value="Acronym">Acronym</option>
                            <option value="Technical">Technical</option>
                            <option value="Legal">Legal</option>
                            <option value="Medical">Medical</option>
                            <option value="Regulatory">Regulatory</option>
                            <option value="Jargon">Jargon</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Source (optional):</label>
                        <input type="text" id="newSource" placeholder="https://www.cdc.gov" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Share Tech Mono', monospace;" />
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button class="header-btn" onclick="saveTerm()" style="flex: 1;">‚úì Add Term</button>
                        <button class="header-btn" onclick="closeDialog()" style="flex: 1; background: rgba(255, 0, 0, 0.2); border-color: #ff0000;">‚úï Cancel</button>
                    </div>
                </div>
                <div id="dialogOverlay" onclick="closeDialog()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 1999;"></div>
            `;
            
            const dialogDiv = document.createElement('div');
            dialogDiv.id = 'termDialog';
            dialogDiv.innerHTML = dialog;
            document.body.appendChild(dialogDiv);
            
            document.getElementById('newTerm').focus();
        }
        
        function closeDialog() {
            const dialog = document.getElementById('termDialog');
            if (dialog) dialog.remove();
        }
        
        function saveTerm() {
            const term = document.getElementById('newTerm').value.trim();
            const definition = document.getElementById('newDefinition').value.trim();
            const category = document.getElementById('newCategory').value;
            const source = document.getElementById('newSource').value.trim();
            
            if (!term || !definition) {
                alert('Please provide both term and definition');
                return;
            }
            
            // Check for duplicates
            if (currentProject.glossary.terms.find(t => t.term.toLowerCase() === term.toLowerCase())) {
                alert('This term already exists in the glossary');
                return;
            }
            
            currentProject.glossary.terms.push({
                term: term,
                definition: definition,
                category: category,
                source: source || null,
                addedDate: new Date().toISOString(),
                usageCount: 0
            });
            
            currentProject.glossary.lastUpdated = new Date().toISOString();
            
            closeDialog();
            updateGlossaryDisplay();
            
            alert(`‚úì Added "${term}" to glossary`);
        }
        
        function removeTerm(termName) {
            if (!confirm(`Remove "${termName}" from glossary?`)) return;
            
            currentProject.glossary.terms = currentProject.glossary.terms.filter(t => t.term !== termName);
            currentProject.glossary.lastUpdated = new Date().toISOString();
            updateGlossaryDisplay();
        }
        
        function loadCDCGlossary() {
            const cdcTerms = [
                // Acronyms
                {term: "CDC", definition: "Centers for Disease Control and Prevention", category: "Acronym", source: "https://www.cdc.gov"},
                {term: "VAERS", definition: "Vaccine Adverse Event Reporting System", category: "Acronym", source: "https://vaers.hhs.gov"},
                {term: "EUA", definition: "Emergency Use Authorization", category: "Acronym"},
                {term: "FDA", definition: "Food and Drug Administration", category: "Acronym"},
                {term: "NIH", definition: "National Institutes of Health", category: "Acronym"},
                {term: "NIAID", definition: "National Institute of Allergy and Infectious Diseases", category: "Acronym"},
                {term: "HHS", definition: "Department of Health and Human Services", category: "Acronym"},
                {term: "WHO", definition: "World Health Organization", category: "Acronym"},
                {term: "PCR", definition: "Polymerase Chain Reaction test for detecting genetic material", category: "Acronym"},
                
                // Technical Terms
                {term: "mRNA", definition: "Messenger Ribonucleic Acid - genetic material that instructs cells to produce proteins", category: "Technical"},
                {term: "Spike Protein", definition: "Viral surface protein that binds to cellular receptors", category: "Technical"},
                {term: "Gain-of-Function", definition: "Research that enhances pathogen transmissibility or virulence", category: "Technical"},
                {term: "Antibody-Dependent Enhancement", definition: "When antibodies enhance viral entry into cells (ADE)", category: "Technical"},
                {term: "Herd Immunity", definition: "Population-level protection from infectious disease", category: "Technical"},
                {term: "R-naught (R0)", definition: "Basic reproduction number of an infection", category: "Technical"},
                
                // Regulatory
                {term: "Clinical Trial Phase I", definition: "Initial small-scale safety testing", category: "Regulatory"},
                {term: "Clinical Trial Phase II", definition: "Expanded safety and efficacy testing", category: "Regulatory"},
                {term: "Clinical Trial Phase III", definition: "Large-scale efficacy and safety confirmation", category: "Regulatory"},
                {term: "Informed Consent", definition: "Patient agreement after full disclosure of risks and benefits", category: "Regulatory"},
                {term: "Adverse Event", definition: "Undesirable medical occurrence following treatment", category: "Regulatory"},
                {term: "Serious Adverse Event", definition: "Life-threatening event or requiring hospitalization (SAE)", category: "Regulatory"},
                {term: "Safety Signal", definition: "Pattern in data suggesting potential risk", category: "Regulatory"},
                {term: "Pharmacovigilance", definition: "Drug safety monitoring and risk management", category: "Regulatory"},
                
                // Legal/Policy
                {term: "PREP Act", definition: "Public Readiness and Emergency Preparedness Act - provides liability immunity", category: "Legal"},
                {term: "FOIA", definition: "Freedom of Information Act - public access to government records", category: "Legal"},
                {term: "Liability Shield", definition: "Legal protection from lawsuits", category: "Legal"},
                {term: "Mandate", definition: "Government requirement or order", category: "Legal"},
                {term: "Public Health Emergency", definition: "Official declaration enabling special government powers", category: "Legal"}
            ];
            
            // Add terms that don't already exist
            let addedCount = 0;
            cdcTerms.forEach(newTerm => {
                if (!currentProject.glossary.terms.find(t => t.term.toLowerCase() === newTerm.term.toLowerCase())) {
                    currentProject.glossary.terms.push({
                        ...newTerm,
                        addedDate: new Date().toISOString(),
                        usageCount: 0
                    });
                    addedCount++;
                }
            });
            
            currentProject.glossary.lastUpdated = new Date().toISOString();
            updateGlossaryDisplay();
            
            alert(`‚úì Added ${addedCount} CDC terms to glossary (${cdcTerms.length - addedCount} already existed)`);
        }
        
        function showImportGlossaryDialog() {
            const dialog = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel-bg); border: 2px solid var(--matrix-green); padding: 30px; border-radius: 8px; z-index: 2000; box-shadow: 0 0 50px rgba(0, 255, 65, 0.3); min-width: 600px; max-width: 800px;">
                    <div style="font-size: 1.3em; margin-bottom: 20px; color: var(--matrix-green); font-family: 'Orbitron', monospace;">üì• Import Glossary JSON</div>
                    
                    <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 0.9em;">
                        Paste glossary JSON from Claude below. Expected format:
                        <pre style="background: rgba(0,0,0,0.5); padding: 10px; margin-top: 10px; border-radius: 4px; font-size: 0.85em;">[
  {
    "term": "CDC",
    "definition": "Centers for Disease Control...",
    "category": "Acronym",
    "source": "https://..."
  }
]</pre>
                    </div>
                    
                    <textarea id="glossaryImportJSON" placeholder="Paste JSON here..." rows="12" style="width: 100%; padding: 15px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Share Tech Mono', monospace; font-size: 0.9em; resize: vertical;"></textarea>
                    
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="header-btn" onclick="importGlossaryJSON()" style="flex: 1;">‚úì Import Terms</button>
                        <button class="header-btn" onclick="closeDialog()" style="flex: 1; background: rgba(255, 0, 0, 0.2); border-color: #ff0000;">‚úï Cancel</button>
                    </div>
                </div>
                <div id="dialogOverlay" onclick="closeDialog()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 1999;"></div>
            `;
            
            const dialogDiv = document.createElement('div');
            dialogDiv.id = 'termDialog';
            dialogDiv.innerHTML = dialog;
            document.body.appendChild(dialogDiv);
            
            document.getElementById('glossaryImportJSON').focus();
        }
        
        function importGlossaryJSON() {
            const jsonText = document.getElementById('glossaryImportJSON').value.trim();
            
            if (!jsonText) {
                alert('Please paste JSON data');
                return;
            }
            
            try {
                // Parse JSON
                const terms = JSON.parse(jsonText);
                
                // Validate it's an array
                if (!Array.isArray(terms)) {
                    alert('JSON must be an array of term objects');
                    return;
                }
                
                // Validate each term has required fields
                let validCount = 0;
                let skippedCount = 0;
                
                terms.forEach(term => {
                    if (!term.term || !term.definition) {
                        console.warn('Skipping invalid term:', term);
                        skippedCount++;
                        return;
                    }
                    
                    // Check if term already exists
                    if (currentProject.glossary.terms.find(t => t.term.toLowerCase() === term.term.toLowerCase())) {
                        console.log('Term already exists, skipping:', term.term);
                        skippedCount++;
                        return;
                    }
                    
                    // Add term with defaults for missing fields
                    currentProject.glossary.terms.push({
                        term: term.term,
                        definition: term.definition,
                        category: term.category || 'Uncategorized',
                        source: term.source || null,
                        addedDate: new Date().toISOString(),
                        usageCount: 0,
                        relatedTerms: term.relatedTerms || []
                    });
                    
                    validCount++;
                });
                
                currentProject.glossary.lastUpdated = new Date().toISOString();
                
                closeDialog();
                updateGlossaryDisplay();
                
                let message = `‚úì Imported ${validCount} terms successfully`;
                if (skippedCount > 0) {
                    message += `\n(Skipped ${skippedCount} - duplicates or invalid)`;
                }
                alert(message);
                
            } catch (error) {
                alert(`Error parsing JSON: ${error.message}\n\nPlease check the format and try again.`);
                console.error('Import error:', error);
            }
        }
        
        // Export entire project summary from main view
        function exportProjectSummary() {
            const options = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel-bg); border: 2px solid var(--matrix-green); padding: 30px; border-radius: 8px; z-index: 2000; box-shadow: 0 0 50px rgba(0, 255, 65, 0.3);">
                    <div style="font-size: 1.3em; margin-bottom: 20px; color: var(--matrix-green); font-family: 'Orbitron', monospace;">Export Project Summary</div>
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <button class="header-btn" onclick="exportFullProjectJSON()" style="width: 100%;">üìÑ Complete Project (JSON)</button>
                        <button class="header-btn" onclick="exportEntitySummaryCSV()" style="width: 100%;">üìä Entity Summary (CSV)</button>
                        <button class="header-btn" onclick="exportFullReportHTML()" style="width: 100%;">üåê Full Report (HTML)</button>
                        <button class="header-btn" onclick="closeExportModal()" style="width: 100%; background: rgba(255, 0, 0, 0.2); border-color: #ff0000;">‚úï Cancel</button>
                    </div>
                </div>
                <div id="exportModalOverlay" onclick="closeExportModal()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 1999;"></div>
            `;
            
            const modalDiv = document.createElement('div');
            modalDiv.id = 'exportModal';
            modalDiv.innerHTML = options;
            document.body.appendChild(modalDiv);
        }
        
        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            if (modal) modal.remove();
        }
        
        function exportFullProjectJSON() {
            const data = {
                ...currentProject,
                exported: new Date().toISOString(),
                version: '1.0'
            };
            const json = JSON.stringify(data, null, 2);
            downloadFile(json, `${currentProject.name}_complete_${Date.now()}.json`, 'application/json');
            closeExportModal();
            alert('‚úÖ Complete project exported as JSON!');
        }
        
        function exportEntitySummaryCSV() {
            let csv = 'Entity Type,Name,Total Mentions,Document Count,Documents\n';
            
            const addEntities = (type, entities) => {
                entities.forEach(e => {
                    const docs = e.documents ? e.documents.map(d => d.docName).join('; ') : '';
                    const docCount = e.documents ? e.documents.length : 1;
                    csv += `"${type}","${e.name}",${e.totalCount},${docCount},"${docs}"\n`;
                });
            };
            
            addEntities('Person', currentProject.aggregatedEntities.people);
            addEntities('Organization', currentProject.aggregatedEntities.organizations);
            addEntities('Location', currentProject.aggregatedEntities.places);
            addEntities('Event', currentProject.aggregatedEntities.events);
            
            downloadFile(csv, `${currentProject.name}_entities_${Date.now()}.csv`, 'text/csv');
            closeExportModal();
            alert('‚úÖ Entity summary exported as CSV!');
        }
        
        function exportFullReportHTML() {
            const html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${currentProject.name} - Complete Research Report</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f5f5; padding: 40px; }
        .header { background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%); color: white; padding: 40px; border-radius: 12px; margin-bottom: 40px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .header h1 { font-size: 2.5em; margin-bottom: 15px; }
        .header .meta { opacity: 0.9; font-size: 1.1em; }
        .section { background: white; padding: 30px; margin-bottom: 25px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .section h2 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 15px; margin-bottom: 20px; font-size: 1.8em; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-box { background: #ecf0f1; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #3498db; }
        .stat-value { font-size: 2em; font-weight: bold; color: #2c3e50; }
        .stat-label { color: #7f8c8d; margin-top: 8px; font-size: 0.9em; }
        .entity-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; }
        .entity-card { background: #ecf0f1; padding: 15px; border-radius: 6px; border-left: 4px solid #3498db; }
        .entity-name { font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .entity-meta { color: #7f8c8d; font-size: 0.85em; }
        .footer { text-align: center; color: #7f8c8d; margin-top: 40px; padding: 20px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${escapeHtml(currentProject.name)}</h1>
        <div class="meta">${currentProject.documents.length} Documents ‚Ä¢ Generated ${new Date().toLocaleString()}</div>
    </div>
    
    <div class="section">
        <h2>Project Statistics</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value">${currentProject.documents.length}</div>
                <div class="stat-label">Documents</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">${currentProject.aggregatedEntities.people.length}</div>
                <div class="stat-label">Unique People</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">${currentProject.aggregatedEntities.organizations.length}</div>
                <div class="stat-label">Organizations</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">${currentProject.aggregatedEntities.places.length}</div>
                <div class="stat-label">Locations</div>
            </div>
            <div class="stat-box">
                <div class="stat-value">${currentProject.aggregatedEntities.events.length}</div>
                <div class="stat-label">Events</div>
            </div>
        </div>
    </div>
    
    ${generateEntitySection('People', currentProject.aggregatedEntities.people)}
    ${generateEntitySection('Organizations', currentProject.aggregatedEntities.organizations)}
    ${generateEntitySection('Locations', currentProject.aggregatedEntities.places)}
    ${generateEntitySection('Events', currentProject.aggregatedEntities.events)}
    
    <div class="footer">
        <p>Generated by Master Research Hub ‚Ä¢ Truth-Seeking Infrastructure</p>
    </div>
</body>
</html>`;
            
            downloadFile(html, `${currentProject.name}_report_${Date.now()}.html`, 'text/html');
            closeExportModal();
            alert('‚úÖ Full research report exported as HTML!');
        }
        
        function generateEntitySection(title, entities) {
            if (entities.length === 0) return '';
            
            const topEntities = entities.slice(0, 50);
            return `
    <div class="section">
        <h2>${title} (${entities.length} total, showing top 50)</h2>
        <div class="entity-grid">
            ${topEntities.map(e => `
                <div class="entity-card">
                    <div class="entity-name">${escapeHtml(e.name)}</div>
                    <div class="entity-meta">
                        ${e.totalCount} mentions
                        ${e.documents ? ` ‚Ä¢ ${e.documents.length} documents` : ''}
                    </div>
                </div>
            `).join('')}
        </div>
    </div>`;
        }
    </script>
</body>
</html>
